# Alpine Skiing Season Prediction Script Documentation

This document provides detailed explanations of each section in the 2026 alpine skiing season prediction R script, explaining the purpose, implementation, and reasoning behind each component.

## Section: {r load-data} - Alpine Data Loading & Validation

### Purpose
This section is responsible for loading the core chronometer data files that contain race results for alpine skiing and performing comprehensive validation to ensure data quality and integrity before any analysis begins.

### Data Sources
The section loads two primary CSV files:
- **Men's data**: `/Users/syverjohansen/ski/elo/python/alpine/polars/excel365/men_chrono.csv`
- **Ladies data**: `/Users/syverjohansen/ski/elo/python/alpine/polars/excel365/ladies_chrono.csv`

These files contain chronological race data generated by the alpine ELO rating system pipeline, with each row representing a single race result for an alpine skier.

### Implementation Details

#### 1. File Existence Validation
```r
# Check if files exist before loading
men_file <- '/Users/syverjohansen/ski/elo/python/alpine/polars/excel365/men_chrono.csv'
ladies_file <- '/Users/syverjohansen/ski/elo/python/alpine/polars/excel365/ladies_chrono.csv'

if (!file.exists(men_file)) stop("Men's alpine data file not found: ", men_file)
if (!file.exists(ladies_file)) stop("Ladies alpine data file not found: ", ladies_file)

cat("✓ Alpine data files exist\n")
```
**Purpose**: Ensures the alpine data files exist before attempting to load them. This prevents cryptic errors later and provides clear feedback if the alpine data pipeline hasn't run or files have been moved.

#### 2. Safe Data Loading with Error Handling
```r
tryCatch({
  M_chrono <- read_csv(men_file, show_col_types = FALSE)
  cat("✓ Men's alpine data loaded:", nrow(M_chrono), "rows\n")
}, error = function(e) {
  stop("Failed to load men's alpine data: ", e$message)
})

tryCatch({
  L_chrono <- read_csv(ladies_file, show_col_types = FALSE)
  cat("✓ Ladies alpine data loaded:", nrow(L_chrono), "rows\n")
}, error = function(e) {
  stop("Failed to load ladies alpine data: ", e$message)
})
```
**Purpose**: Uses `tryCatch()` to handle potential file corruption, permission issues, or formatting problems. The `show_col_types = FALSE` suppresses column type messages for cleaner output. Immediately reports the number of rows loaded for verification.

#### 3. Required Column Validation
```r
# Validate required columns exist
required_cols <- c("Skier", "Date", "Season", "Event", "Nation", "Distance", "Place", "Race", "ID")
missing_men <- setdiff(required_cols, names(M_chrono))
missing_ladies <- setdiff(required_cols, names(L_chrono))

if (length(missing_men) > 0) {
  stop("Missing required columns in men's alpine data: ", paste(missing_men, collapse = ", "))
}
if (length(missing_ladies) > 0) {
  stop("Missing required columns in ladies alpine data: ", paste(missing_ladies, collapse = ", "))
}
cat("✓ All required columns present in both alpine datasets\n")
```
**Purpose**: Validates that all essential columns are present in the loaded alpine data. These columns are critical for:
- **Skier**: Athlete identification
- **Date**: Race timing and chronological ordering
- **Season**: Season grouping for analysis
- **Event**: Race type classification (World Cup, etc.)
- **Nation**: Country representation
- **Distance**: Discipline classification in alpine skiing
- **Place**: Finishing position for points calculation
- **Race**: Race identifier within the dataset
- **ID**: Unique skier identifier for linking with other datasets

#### 4. Data Quality Validation

##### Empty Dataset Protection
```r
# Check for completely empty datasets
if (nrow(M_chrono) == 0) stop("Men's alpine dataset is empty")
if (nrow(L_chrono) == 0) stop("Ladies alpine dataset is empty")
```
**Purpose**: Prevents analysis from proceeding with empty datasets, which would cause downstream errors.

##### Place Column Validation
```r
# Check Place column (should be positive integers)
invalid_places_m <- sum(is.na(M_chrono$Place) | M_chrono$Place < 0 | !is.finite(M_chrono$Place))
invalid_places_l <- sum(is.na(L_chrono$Place) | L_chrono$Place < 0 | !is.finite(L_chrono$Place))

cat("Men's invalid Place values:", invalid_places_m, "\n")
cat("Ladies invalid Place values:", invalid_places_l, "\n")

if (invalid_places_m > nrow(M_chrono) * 0.1) {
  warning("More than 10% of men's Place values are invalid")
}
if (invalid_places_l > nrow(L_chrono) * 0.1) {
  warning("More than 10% of ladies Place values are invalid")
}
```
**Purpose**: Validates that finishing places are logical (positive integers). The 10% threshold allows for some data imperfections (DNS, DSQ, DNF) while flagging systematic data quality issues.

##### Skier Name Validation
```r
# Check for missing Skier names
missing_skiers_m <- sum(is.na(M_chrono$Skier) | M_chrono$Skier == "")
missing_skiers_l <- sum(is.na(L_chrono$Skier) | L_chrono$Skier == "")

cat("Men's missing skier names:", missing_skiers_m, "\n")
cat("Ladies missing skier names:", missing_skiers_l, "\n")

if (missing_skiers_m > nrow(M_chrono) * 0.05) {
  warning("More than 5% of men's skier names are missing")
}
if (missing_skiers_l > nrow(L_chrono) * 0.05) {
  warning("More than 5% of ladies skier names are missing")
}
```
**Purpose**: Ensures all race results can be attributed to specific athletes. Missing skier names would break the analysis pipeline. Uses a 5% threshold for skier name completeness.

##### Season Range Validation
```r
# Check Season range
season_range_m <- range(M_chrono$Season, na.rm = TRUE)
season_range_l <- range(L_chrono$Season, na.rm = TRUE)

cat("Men's season range:", season_range_m[1], "to", season_range_m[2], "\n")
cat("Ladies season range:", season_range_l[1], "to", season_range_l[2], "\n")

# Expected season range (adjust based on your data)
expected_min_season <- 2010
expected_max_season <- 2025

if (season_range_m[1] < expected_min_season || season_range_m[2] > expected_max_season) {
  warning("Men's season range outside expected bounds: ", expected_min_season, "-", expected_max_season)
}
if (season_range_l[1] < expected_min_season || season_range_l[2] > expected_max_season) {
  warning("Ladies season range outside expected bounds: ", expected_min_season, "-", expected_max_season)
}
```
**Purpose**: Validates that season data falls within expected ranges (2010-2025), helping identify data import issues or unexpected historical data.

##### Date Validation
```r
# Date validation
date_errors_m <- sum(is.na(M_chrono$Date))
date_errors_l <- sum(is.na(L_chrono$Date))

cat("Men's invalid dates:", date_errors_m, "\n")
cat("Ladies invalid dates:", date_errors_l, "\n")
```
**Purpose**: Validates that race dates are present, which is essential for chronological analysis and season grouping.

#### 5. Alpine Athlete Exclusion System
```r
# 2025 Retirements - Men
excluded_men <- c("Yannick Chabloz", "Sebastian Foss-Solevåg", "Nico Gauer", 
                  "Stefano Gross", "Boštjan Kline", "Urs Kryenbühl", 
                  "Stefan Luitz", "Adrian Meisen", "Reto Schmidiger", 
                  "Dominik Schwaiger", "Rasmus Windingstad")

# 2025 Retirements - Ladies  
excluded_ladies <- c("Michelle Niederwieser", "Roni Remme", "Charlotta Säfvenberg",
                     "Anna Schillinger", "Elena Stoffel", "Tamara Tippler",
                     "Vera Tschurtschenthaler", "Stephanie Venier")

cat("\n--- Alpine Athlete Exclusion ---\n")
cat("Excluding men:", paste(excluded_men, collapse = ", "), "\n")
cat("Excluding ladies:", paste(excluded_ladies, collapse = ", "), "\n")

# Count how many records will be excluded
excluded_count_m <- sum(M_chrono$Skier %in% excluded_men)
excluded_count_l <- sum(L_chrono$Skier %in% excluded_ladies)

cat("Men's records to exclude:", excluded_count_m, "\n")
cat("Ladies records to exclude:", excluded_count_l, "\n")
```
**Purpose**: Removes specific athletes from analysis who have retired or are inactive in 2025, ensuring predictions focus on active competitors for the 2026 season.

**Exclusion Tracking**: The system counts how many records will be excluded before performing the operation, providing transparency about the impact of exclusions.

#### 6. Exclusion Validation and Verification
```r
# Filter out excluded athletes from raw data
M_chrono_original_rows <- nrow(M_chrono)
L_chrono_original_rows <- nrow(L_chrono)

M_chrono <- M_chrono %>%
  filter(!Skier %in% excluded_men)

L_chrono <- L_chrono %>%
  filter(!Skier %in% excluded_ladies)

# Verify exclusion worked correctly
actual_excluded_m <- M_chrono_original_rows - nrow(M_chrono)
actual_excluded_l <- L_chrono_original_rows - nrow(L_chrono)

if (actual_excluded_m != excluded_count_m) {
  warning("Mismatch in men's exclusion: expected ", excluded_count_m, ", actual ", actual_excluded_m)
}
if (actual_excluded_l != excluded_count_l) {
  warning("Mismatch in ladies exclusion: expected ", excluded_count_l, ", actual ", actual_excluded_l)
}

cat("✓ Men's alpine data after exclusion:", nrow(M_chrono), "rows\n")
cat("✓ Ladies alpine data after exclusion:", nrow(L_chrono), "rows\n")
```
**Purpose**: Validates that the exclusion process worked correctly by comparing expected vs. actual excluded record counts. This ensures data integrity and catches any issues with the exclusion logic.

#### 7. Alpine World Cup Points System Setup
```r
# Alpine World Cup points mapping with validation
cat("\n--- Alpine Points System Validation ---\n")

# Standard alpine World Cup points (top 30 get points)
alpine_points <- c(100,80,60,50,45,40,36,32,29,26,24,22,20,18,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)
```
**Purpose**: Establishes the official Alpine World Cup points system where only the top 30 finishers receive points, with winners receiving 100 points and decreasing amounts down to 1 point for 30th place.

**Alpine Points System Characteristics**:
- **Winner Premium**: 100 points for 1st place, 80 for 2nd (20-point gap rewards victories)
- **Limited Scoring**: Only top 30 athletes score points (more exclusive than some other sports)
- **Standard Structure**: Consistent across all alpine disciplines

### Alpine-Specific Design Considerations

#### Points System Differences
Alpine skiing uses a single, standardized points system across all disciplines:
- **Uniform Structure**: Same points (100-80-60-50...) regardless of whether it's Downhill, Slalom, Giant Slalom, Super G, or Combined
- **Limited Scoring Positions**: Only top 30 receive points (creates competitive pressure)
- **High Winner Premium**: Large gap between 1st and 2nd place rewards race victories

#### Data Quality Thresholds
The validation uses sport-appropriate thresholds:
- **Place Values**: 10% tolerance for invalid places (accounts for DNF/DSQ common in alpine)
- **Skier Names**: 5% tolerance for missing names (stricter than place tolerance)
- **Season Range**: 2010-2025 (modern alpine World Cup era)

#### Exclusion Strategy
The exclusion system targets:
- **2025 Retirements**: Athletes who retired after the 2025 season
- **Active Competition Focus**: Ensures predictions are relevant for athletes likely to compete in 2026
- **Comprehensive Coverage**: Separate lists for men and ladies account for different retirement patterns

### Error Handling and Robustness
- **File Validation**: Confirms alpine data files exist and are accessible
- **Column Validation**: Ensures all required fields for alpine analysis are present
- **Data Quality Monitoring**: Uses sport-appropriate thresholds for data quality metrics
- **Exclusion Validation**: Verifies athlete exclusions worked as expected
- **Comprehensive Logging**: Provides detailed feedback on each validation step

This alpine data loading section provides a robust foundation for all subsequent alpine skiing analysis, ensuring data quality and establishing the analytical framework specific to alpine racing's competitive structure and points system.

## Section: {r process-data} - Alpine Data Processing & Feature Engineering

### Purpose
This section implements comprehensive data processing and feature engineering specifically designed for alpine skiing performance analysis. It transforms raw chronometer data into analysis-ready datasets with alpine-specific metrics, cumulative performance tracking, and validation checks.

### Implementation Details

#### 1. Core Processing Function: `process_alpine_chrono_data()`
The section centers around a robust processing function tailored for alpine skiing data:

```r
process_alpine_chrono_data <- function(chrono_df, data_name = "Unknown") {
  
  cat(sprintf("\n--- Processing %s Alpine Data ---\n", data_name))
  
  # Input validation
  if (nrow(chrono_df) == 0) {
    stop(sprintf("%s alpine dataset is empty", data_name))
  }
  
  # Check for required columns before processing
  required_cols <- c("Event", "Nation", "Place", "Distance", "Date", "Race", "ID", "Season")
  missing_cols <- setdiff(required_cols, names(chrono_df))
  if (length(missing_cols) > 0) {
    stop(sprintf("Missing required columns in %s alpine data: %s", data_name, paste(missing_cols, collapse = ", ")))
  }
  
  original_rows <- nrow(chrono_df)
  cat(sprintf("Input: %d rows\n", original_rows))
}
```

**Purpose**: Provides a specialized framework for processing alpine skiing data that handles the sport's unique competitive structure and points system.

**Key Features**:
- **Parameterized Processing**: Accepts data name for detailed logging
- **Input Validation**: Ensures data integrity before processing
- **Column Validation**: Verifies all required fields are present
- **Progress Tracking**: Reports processing steps with row counts

#### 2. Alpine Points Assignment and Validation
```r
# Add Alpine World Cup points
cat("Adding Alpine World Cup points...\n")
df <- chrono_df %>%
  mutate(Points = map_int(Place, ~ get_alpine_points(.x, alpine_points)))

# Validate points assignment
points_na <- sum(is.na(df$Points))
points_negative <- sum(df$Points < 0, na.rm = TRUE)

if (points_na > 0) {
  warning(sprintf("%s: %d rows have NA points", data_name, points_na))
}
if (points_negative > 0) {
  warning(sprintf("%s: %d rows have negative points", data_name, points_negative))
}

cat(sprintf("Alpine points range: %d - %d\n", min(df$Points, na.rm = TRUE), max(df$Points, na.rm = TRUE)))
```

**Purpose**: Applies the Alpine World Cup points system to race results and validates the assignment process.

**Points Assignment Logic**:
- Uses `get_alpine_points()` function to safely assign points based on placement
- Awards 100 points for 1st place down to 1 point for 30th place
- Returns 0 points for placements outside top 30
- Handles edge cases (NA, negative, or invalid placements)

**Validation Features**:
- Checks for NA points assignments
- Identifies negative points (should not occur)
- Reports points range for verification

#### 3. Event Filtering and Competition Focus
```r
# Count events before filtering
event_counts_before <- table(df$Event)
cat("Events before filtering:\n")
print(event_counts_before)

# Filter for relevant alpine events (only World Cup and Offseason)
cat("Filtering for relevant alpine events (World Cup, Offseason)...\n")
relevant_events <- c("World Cup", "Offseason")

df <- df %>%
  filter(Event %in% relevant_events) %>%
  arrange(Date, Race, Place) %>%
  group_by(ID, Season) %>%
  mutate(
    Cumulative_Points = cumsum(Points),
    Races_in_Season = n()
  ) %>%
  ungroup()

filtered_rows <- nrow(df)
cat(sprintf("After alpine event filtering: %d rows (removed %d rows)\n", filtered_rows, original_rows - filtered_rows))

# Count events after filtering
event_counts_after <- table(df$Event)
cat("Alpine events after filtering:\n")
print(event_counts_after)
```

**Purpose**: Focuses analysis on the most relevant competitions for performance prediction while tracking filtering impact.

**Event Filtering Logic**:
- **World Cup**: Primary elite alpine racing circuit
- **Offseason**: Summer and training competitions
- **Exclusions**: Removes lower-level competitions that are less predictive

**Feature Engineering**:
- **Cumulative_Points**: Running total of points earned within each season
- **Races_in_Season**: Count of races participated in each season
- **Date Ordering**: Ensures chronological processing for cumulative calculations

#### 4. Cumulative Points Calculation Validation
```r
# Validate cumulative points calculation
invalid_cumulative <- df %>%
  group_by(ID, Season) %>%
  mutate(expected_cumulative = cumsum(Points)) %>%
  ungroup() %>%
  filter(Cumulative_Points != expected_cumulative) %>%
  nrow()

if (invalid_cumulative > 0) {
  warning(sprintf("%s: %d rows have incorrect cumulative points", data_name, invalid_cumulative))
} else {
  cat("✓ Cumulative points calculation validated\n")
}
```

**Purpose**: Validates that cumulative points are calculated correctly by comparing against expected values.

**Validation Method**:
- Recalculates cumulative points independently
- Compares against stored cumulative values
- Identifies any discrepancies in the calculation
- Ensures data integrity for downstream analysis

#### 5. Alpine Discipline Analysis
```r
# Alpine doesn't have team events like cross-country, but check for any unusual distances
cat("Checking alpine disciplines...\n")
discipline_counts <- table(df$Distance)
cat("Alpine disciplines:\n")
print(discipline_counts)
```

**Purpose**: Analyzes the distribution of alpine disciplines to ensure comprehensive coverage and identify any data anomalies.

**Alpine Discipline Context**:
- **Individual Events Only**: Unlike cross-country, alpine has no team events
- **Multiple Disciplines**: Downhill, Super G, Giant Slalom, Slalom, Combined
- **Distance Field Usage**: The Distance field contains discipline information in alpine data

#### 6. Maximum Points Calculation and Percentage Metrics
```r
# Calculate maximum possible points per season 
cat("Calculating maximum possible alpine points per season...\n")
max_points_per_season <- df %>%
  group_by(Season, Date, Race) %>%
  summarise(Max_Race_Points = max(Points), .groups = 'drop') %>%
  group_by(Season) %>%
  summarise(Max_Points = sum(Max_Race_Points), .groups = 'drop')

# Validate max points calculation
if (nrow(max_points_per_season) == 0) {
  stop(sprintf("%s: No seasons found for alpine max points calculation", data_name))
}

# Check for seasons with zero max points
zero_max_seasons <- max_points_per_season %>% filter(Max_Points == 0)
if (nrow(zero_max_seasons) > 0) {
  warning(sprintf("%s: %d alpine seasons have zero max points", data_name, nrow(zero_max_seasons)))
  print(zero_max_seasons)
}

cat(sprintf("Alpine max points range by season: %d - %d\n", 
            min(max_points_per_season$Max_Points), max(max_points_per_season$Max_Points)))
```

**Purpose**: Calculates the theoretical maximum points possible in each season to enable performance percentage calculations.

**Maximum Points Logic**:
- **Race-Level Maximum**: Finds highest points awarded in each race (typically 100 for winners)
- **Season Aggregation**: Sums maximum points across all races in each season
- **Validation**: Ensures all seasons have positive maximum points

**Performance Standardization**: Enables comparison across different seasons with varying numbers of races.

#### 7. Performance Percentage Calculation and Validation
```r
# Join max points and calculate percentage
cat("Calculating percentage of maximum alpine points...\n")
before_join <- nrow(df)

df <- df %>%
  left_join(max_points_per_season, by = "Season") %>%
  mutate(Pct_of_Max_Points = Cumulative_Points / Max_Points)

after_join <- nrow(df)
if (before_join != after_join) {
  warning(sprintf("%s: Row count changed during alpine max points join: %d -> %d", data_name, before_join, after_join))
}

# Validate percentage calculations
pct_na <- sum(is.na(df$Pct_of_Max_Points))
pct_negative <- sum(df$Pct_of_Max_Points < 0, na.rm = TRUE)
pct_over_one <- sum(df$Pct_of_Max_Points > 1, na.rm = TRUE)

if (pct_na > 0) {
  warning(sprintf("%s: %d rows have NA percentage of max alpine points", data_name, pct_na))
}
if (pct_negative > 0) {
  warning(sprintf("%s: %d rows have negative percentage of max alpine points", data_name, pct_negative))
}
if (pct_over_one > 0) {
  warning(sprintf("%s: %d rows have percentage > 100%% of max alpine points", data_name, pct_over_one))
}

cat(sprintf("Alpine percentage range: %.3f - %.3f\n", 
            min(df$Pct_of_Max_Points, na.rm = TRUE), max(df$Pct_of_Max_Points, na.rm = TRUE)))
```

**Purpose**: Creates standardized performance metrics by calculating what percentage of maximum possible points each athlete achieved.

**Percentage Calculation**:
- **Formula**: (Cumulative Points / Season Max Points)
- **Range**: 0.0 (no points) to 1.0 (won every race)
- **Standardization**: Enables comparison across different season lengths

**Validation Checks**:
- **Row Count**: Ensures join operation doesn't change data size
- **NA Values**: Identifies missing percentage calculations
- **Range**: Validates percentages are between 0 and 1
- **Logical Constraints**: Flags impossible values (negative or >100%)

#### 8. Final Validation and Summary Statistics
```r
# Final validation checks
cat("\n--- Final Alpine Validation ---\n")

# Check for required columns in output
expected_output_cols <- c("Points", "Cumulative_Points", "Races_in_Season", "Max_Points", "Pct_of_Max_Points")
missing_output_cols <- setdiff(expected_output_cols, names(df))
if (length(missing_output_cols) > 0) {
  stop(sprintf("%s: Missing expected alpine output columns: %s", data_name, paste(missing_output_cols, collapse = ", ")))
}

# Summary statistics
cat(sprintf("✓ Alpine processing complete for %s\n", data_name))
cat(sprintf("Final rows: %d (%.1f%% of original)\n", nrow(df), 100 * nrow(df) / original_rows))
cat(sprintf("Unique alpine skiers: %d\n", length(unique(df$Skier))))
cat(sprintf("Alpine seasons covered: %d (%s - %s)\n", 
            length(unique(df$Season)), min(df$Season), max(df$Season)))
cat(sprintf("Average alpine races per season per skier: %.1f\n", mean(df$Races_in_Season)))
```

**Purpose**: Provides final validation and comprehensive summary of the processed alpine data.

**Output Validation**:
- **Required Columns**: Ensures all expected columns are present
- **Data Completeness**: Reports final data size and retention rate
- **Coverage Metrics**: Summarizes unique skiers and season coverage
- **Racing Activity**: Reports average participation rates

#### 9. Cross-Dataset Processing and Validation
```r
# Process both alpine datasets with validation
cat("\n=== PROCESSING MEN'S ALPINE DATA ===\n")
tryCatch({
  M_processed <- process_alpine_chrono_data(M_chrono, "Men's")
}, error = function(e) {
  stop("Failed to process men's alpine data: ", e$message)
})

cat("\n=== PROCESSING LADIES ALPINE DATA ===\n")
tryCatch({
  L_processed <- process_alpine_chrono_data(L_chrono, "Ladies")
}, error = function(e) {
  stop("Failed to process ladies alpine data: ", e$message)
})

# Cross-validation between alpine datasets
cat("\n=== CROSS-DATASET ALPINE VALIDATION ===\n")

# Compare season ranges
men_seasons <- sort(unique(M_processed$Season))
ladies_seasons <- sort(unique(L_processed$Season))

cat("Men's alpine seasons:", paste(range(men_seasons), collapse = " - "), "(", length(men_seasons), "seasons )\n")
cat("Ladies alpine seasons:", paste(range(ladies_seasons), collapse = " - "), "(", length(ladies_seasons), "seasons )\n")

# Check for season overlap
common_seasons <- intersect(men_seasons, ladies_seasons)
cat("Common alpine seasons:", length(common_seasons), "\n")

if (length(common_seasons) == 0) {
  warning("No common seasons between men's and ladies alpine data")
}
```

**Purpose**: Applies processing to both men's and women's alpine data and validates consistency between datasets.

**Cross-Validation Features**:
- **Parallel Processing**: Applies same function to both datasets
- **Error Handling**: Isolates processing errors to specific datasets
- **Season Coverage**: Compares temporal coverage between datasets
- **Overlap Analysis**: Ensures adequate common data for comparative analysis

#### 10. Star Athlete Validation Testing
```r
# Test with star athletes to validate processing
cat("\n=== ALPINE STAR ATHLETE VALIDATION ===\n")

# Test Marco Odermatt (men)
odermatt_data <- M_processed %>% 
  filter(Skier == "Marco Odermatt") %>%
  arrange(Season, Date)

if (nrow(odermatt_data) > 0) {
  cat("✓ Marco Odermatt found in men's data\n")
  cat(sprintf("  Seasons: %s - %s\n", min(odermatt_data$Season), max(odermatt_data$Season)))
  cat(sprintf("  Total races: %d\n", nrow(odermatt_data)))
  cat(sprintf("  Career points: %d\n", sum(odermatt_data$Points)))
  
  # Show recent season performance
  recent_season <- max(odermatt_data$Season)
  recent_data <- odermatt_data %>% filter(Season == recent_season)
  cat(sprintf("  %d season: %d races, %d points, %.1f%% of max\n", 
              recent_season, nrow(recent_data), sum(recent_data$Points),
              max(recent_data$Pct_of_Max_Points) * 100))
} else {
  warning("Marco Odermatt not found in men's alpine data")
}
```

**Purpose**: Validates processing accuracy using known high-performing athletes as test cases.

**Validation Athletes**:
- **Marco Odermatt**: Top men's alpine skier for validation
- **Mikaela Shiffrin**: Top women's alpine skier for validation

**Test Metrics**:
- **Data Presence**: Confirms star athletes are found in processed data
- **Career Span**: Validates reasonable season coverage
- **Performance Metrics**: Checks points and percentage calculations
- **Recent Performance**: Validates latest season data

### Alpine-Specific Design Considerations

#### Single Points System
Alpine skiing uses one consistent points system:
- **Uniform Application**: Same points structure across all disciplines
- **Top 30 Scoring**: Only top 30 finishers receive points
- **Winner Premium**: 100 points for victory vs. 80 for second place

#### Event Hierarchy
Processing focuses on performance-relevant competitions:
- **World Cup**: Primary elite circuit (highest priority)
- **Offseason**: Training and summer competitions (secondary priority)
- **Lower Levels**: Excluded to focus on predictive competitions

#### Performance Standardization
Percentage calculations account for alpine skiing characteristics:
- **Variable Schedules**: Athletes compete in different numbers of races
- **Discipline Specialization**: Some athletes focus on specific disciplines
- **Season Length Variation**: Different seasons may have different race calendars

### Error Handling and Quality Assurance
- **Input Validation**: Comprehensive checks for data structure and completeness
- **Processing Validation**: Validates each step of feature engineering and calculation
- **Cross-Dataset Consistency**: Ensures consistent processing across men's and women's data
- **Star Athlete Testing**: Uses known high performers to validate processing accuracy
- **Comprehensive Logging**: Detailed progress reporting and diagnostic output

This alpine data processing section provides a robust foundation for subsequent analysis, creating standardized performance metrics while preserving the unique characteristics of alpine skiing competition and its points system.

## Section: {r elo-prep} - Alpine ELO Data Preparation & Feature Engineering

### Purpose
This section prepares alpine ELO (rating system) data for machine learning models by filtering offseason data, creating lagged features for previous season performance, and implementing comprehensive missing value treatment specific to alpine skiing's multi-discipline structure.

### Implementation Details

#### 1. Missing Value Helper Function
```r
# Helper function for quartile replacement (handles NAs by replacing with 1st quartile within season)
replace_na_with_quartile <- function(x, var_name) {
  if (all(is.na(x))) {
    warning(sprintf("All values NA for %s in this season - using global mean", var_name))
    return(rep(mean(x, na.rm = TRUE), length(x)))
  }
  
  q1 <- quantile(x, 0.25, na.rm = TRUE)
  if (is.na(q1)) {
    warning(sprintf("Cannot calculate quartile for %s - using mean", var_name))
    q1 <- mean(x, na.rm = TRUE)
  }
  
  return(replace(x, is.na(x), q1))
}
```

**Purpose**: Provides robust missing value imputation using first quartile values within each season, with fallback strategies for edge cases.

**Imputation Strategy**:
- **Primary Method**: Uses first quartile (25th percentile) within season
- **Fallback 1**: If all values are NA in season, uses global mean
- **Fallback 2**: If quartile calculation fails, uses season mean
- **Conservative Approach**: First quartile provides conservative estimates for missing ELO ratings

#### 2. Core ELO Preparation Function
```r
prepare_alpine_elo_data <- function(processed_df, data_name = "Unknown") {
  
  cat(sprintf("\n--- Preparing %s Alpine ELO Data ---\n", data_name))
  
  # Input validation
  if (nrow(processed_df) == 0) {
    stop(sprintf("%s alpine dataset is empty", data_name))
  }
  
  original_rows <- nrow(processed_df)
  cat(sprintf("Input: %d rows\n", original_rows))
  
  # Check for offseason data
  offseason_count <- sum(processed_df$Event == "Offseason", na.rm = TRUE)
  cat(sprintf("Offseason events available: %d\n", offseason_count))
  
  if (offseason_count == 0) {
    stop(sprintf("%s: No offseason data found for alpine ELO preparation", data_name))
  }
}
```

**Purpose**: Establishes the framework for alpine ELO data preparation with comprehensive validation.

**Key Validation Steps**:
- **Empty Dataset Check**: Ensures data is available for processing
- **Offseason Data Requirement**: Validates presence of offseason data (essential for ELO preparation)
- **Progress Tracking**: Reports input data size and availability

#### 3. Alpine ELO Column Validation
```r
# Check for required alpine ELO columns before processing
required_elo_cols <- c("Pelo", "Downhill_Pelo", "Super G_Pelo", "Giant Slalom_Pelo", 
                       "Slalom_Pelo", "Combined_Pelo", "Tech_Pelo", "Speed_Pelo")

available_elo_cols <- intersect(required_elo_cols, names(processed_df))
missing_elo_cols <- setdiff(required_elo_cols, names(processed_df))

cat(sprintf("Available alpine ELO columns: %d/%d\n", length(available_elo_cols), length(required_elo_cols)))
if (length(missing_elo_cols) > 0) {
  cat("Missing alpine ELO columns:", paste(missing_elo_cols, collapse = ", "), "\n")
  warning(sprintf("%s: Missing some alpine ELO columns - proceeding with available columns", data_name))
}
```

**Purpose**: Validates availability of alpine-specific ELO rating columns and handles graceful degradation if some are missing.

**Alpine ELO Structure**:
- **Pelo**: Overall alpine ELO rating
- **Downhill_Pelo**: Downhill-specific ELO rating
- **Super G_Pelo**: Super G-specific ELO rating
- **Giant Slalom_Pelo**: Giant Slalom-specific ELO rating
- **Slalom_Pelo**: Slalom-specific ELO rating
- **Combined_Pelo**: Combined event ELO rating
- **Tech_Pelo**: Technical disciplines (Slalom, Giant Slalom) aggregate ELO
- **Speed_Pelo**: Speed disciplines (Downhill, Super G) aggregate ELO

**Flexible Processing**: Continues with available columns if some ELO ratings are missing.

#### 4. Offseason Data Filtering and Lag Feature Creation
```r
# Filter for offseason data and create previous season ELO values
cat("Filtering for offseason data and creating lag features...\n")

elo_df <- processed_df %>%
  filter(Event == "Offseason") %>%
  arrange(ID, Season)

filtered_rows <- nrow(elo_df)
cat(sprintf("After offseason filter: %d rows (%.1f%% of input)\n", 
            filtered_rows, 100 * filtered_rows / original_rows))

if (filtered_rows == 0) {
  stop(sprintf("%s: No rows remaining after offseason filtering", data_name))
}

# Create lag features for alpine disciplines with validation
cat("Creating alpine discipline lag features...\n")

elo_df <- elo_df %>%
  group_by(ID) %>%
  mutate(
    Prev_Pelo = if("Pelo" %in% names(.)) lag(Pelo) else NA_real_,
    Prev_Downhill = if("Downhill_Pelo" %in% names(.)) lag(Downhill_Pelo) else NA_real_,
    Prev_Super_G = if("Super G_Pelo" %in% names(.)) lag(`Super G_Pelo`) else NA_real_,
    Prev_Giant_Slalom = if("Giant Slalom_Pelo" %in% names(.)) lag(`Giant Slalom_Pelo`) else NA_real_,
    Prev_Slalom = if("Slalom_Pelo" %in% names(.)) lag(Slalom_Pelo) else NA_real_,
    Prev_Combined = if("Combined_Pelo" %in% names(.)) lag(Combined_Pelo) else NA_real_,
    Prev_Tech = if("Tech_Pelo" %in% names(.)) lag(Tech_Pelo) else NA_real_,
    Prev_Speed = if("Speed_Pelo" %in% names(.)) lag(Speed_Pelo) else NA_real_,
    Prev_Pct_of_Max_Points = lag(Pct_of_Max_Points)
  ) %>%
  ungroup()
```

**Purpose**: Extracts offseason data and creates lagged features representing previous season performance across all alpine disciplines.

**Offseason Focus**: 
- **End-of-Season Snapshot**: Offseason data represents final ELO ratings after season completion
- **Predictive Features**: Previous season ELO ratings serve as predictors for next season performance
- **Clean Temporal Ordering**: Arranges by athlete ID and season for proper lag calculation

**Lag Feature Engineering**:
- **Previous Overall Rating**: `Prev_Pelo` for general alpine ability
- **Discipline-Specific Ratings**: Previous ELO for each alpine discipline
- **Aggregate Category Ratings**: Previous Technical and Speed ELO ratings
- **Performance Percentage**: Previous season's percentage of maximum points achieved

#### 5. Season Filtering and Validation
```r
# Apply season filter
cat("Applying season filter (> 2015)...\n")
before_season_filter <- nrow(elo_df)

elo_df <- elo_df %>%
  filter(Season > 2015)

after_season_filter <- nrow(elo_df)
cat(sprintf("After season filter: %d rows (removed %d rows from ≤2015)\n", 
            after_season_filter, before_season_filter - after_season_filter))

if (after_season_filter == 0) {
  stop(sprintf("%s: No rows remaining after alpine season filtering (>2015)", data_name))
}

# Validate season range
season_range <- range(elo_df$Season, na.rm = TRUE)
cat(sprintf("Final alpine season range: %.0f - %.0f\n", season_range[1], season_range[2]))
```

**Purpose**: Focuses analysis on modern alpine skiing era (post-2015) to ensure ELO ratings reflect current competitive dynamics.

**Season Filter Rationale**:
- **Modern Era Focus**: 2016+ represents current alpine skiing competitive structure
- **ELO System Stability**: Ensures ELO ratings have stabilized and are reliable
- **Equipment and Rule Consistency**: Reduces impact of equipment changes and rule modifications
- **Data Quality**: More recent data has better quality and completeness

#### 6. Comprehensive Missing Value Treatment
```r
# Handle missing values by replacing with quartiles within each season
cat("\n--- Alpine ELO Missing Value Treatment ---\n")

# Count NAs before treatment
if (length(created_lag_features) > 0) {
  available_lag_features <- intersect(created_lag_features, names(elo_df))
  if (length(available_lag_features) > 0) {
    na_summary_before <- elo_df[available_lag_features] %>%
      summarise_all(~ sum(is.na(.))) %>%
      gather(variable, na_count) %>%
      filter(na_count > 0)
  }
}

if (nrow(na_summary_before) > 0) {
  cat("Alpine ELO NAs before treatment:\n")
  print(na_summary_before)
} else {
  cat("No NAs found in alpine lag features\n")
}

# Apply quartile replacement by season for alpine disciplines
cat("Applying quartile replacement by season for alpine disciplines...\n")

elo_df <- elo_df %>%
  group_by(Season) %>%
  mutate(
    Prev_Downhill = if("Prev_Downhill" %in% names(.)) replace_na_with_quartile(Prev_Downhill, "Prev_Downhill") else Prev_Downhill,
    Prev_Super_G = if("Prev_Super_G" %in% names(.)) replace_na_with_quartile(Prev_Super_G, "Prev_Super_G") else Prev_Super_G,
    Prev_Giant_Slalom = if("Prev_Giant_Slalom" %in% names(.)) replace_na_with_quartile(Prev_Giant_Slalom, "Prev_Giant_Slalom") else Prev_Giant_Slalom,
    Prev_Slalom = if("Prev_Slalom" %in% names(.)) replace_na_with_quartile(Prev_Slalom, "Prev_Slalom") else Prev_Slalom,
    Prev_Combined = if("Prev_Combined" %in% names(.)) replace_na_with_quartile(Prev_Combined, "Prev_Combined") else Prev_Combined,
    Prev_Tech = if("Prev_Tech" %in% names(.)) replace_na_with_quartile(Prev_Tech, "Prev_Tech") else Prev_Tech,
    Prev_Speed = if("Prev_Speed" %in% names(.)) replace_na_with_quartile(Prev_Speed, "Prev_Speed") else Prev_Speed,
    Prev_Pelo = if("Prev_Pelo" %in% names(.)) replace_na_with_quartile(Prev_Pelo, "Prev_Pelo") else Prev_Pelo,
    Prev_Pct_of_Max_Points = replace(Prev_Pct_of_Max_Points, is.na(Prev_Pct_of_Max_Points), 0)
  ) %>%
  ungroup()
```

**Purpose**: Implements sophisticated missing value imputation that respects alpine skiing's competitive context and seasonal variations.

**Season-Based Imputation Strategy**:
- **Within-Season Context**: Replaces missing ELO values using quartiles within the same season
- **Conservative Estimates**: First quartile provides conservative performance estimates
- **Discipline-Specific Treatment**: Each alpine discipline gets independent imputation
- **Performance Points Special Case**: Missing performance percentages set to 0 (indicating no previous season success)

**Quality Assurance**:
- **Before/After Comparison**: Tracks missing value counts before and after treatment
- **Validation Reporting**: Reports remaining missing values if any exist
- **Error Handling**: Warns if imputation is incomplete

#### 7. Final Data Quality Validation
```r
# Final validation checks
cat("\n--- Final Alpine ELO Validation ---\n")

# Check for infinite values
numeric_cols <- select_if(elo_df, is.numeric) %>% names()
if (length(numeric_cols) > 0) {
  inf_check <- elo_df[numeric_cols] %>%
    summarise_all(~ sum(!is.finite(.))) %>%
    gather(variable, inf_count) %>%
    filter(inf_count > 0)
}

if (nrow(inf_check) > 0) {
  cat("Infinite values found in alpine ELO data:\n")
  print(inf_check)
  warning(sprintf("%s: Contains infinite values", data_name))
} else {
  cat("✓ No infinite values detected in alpine ELO data\n")
}

# Validate key relationships for alpine
if ("Age" %in% names(elo_df)) {
  age_issues <- elo_df %>%
    filter(Age < 15 | Age > 50) %>%
    nrow()
  
  if (age_issues > 0) {
    warning(sprintf("%s: %d rows with unusual ages (<15 or >50)", data_name, age_issues))
  }
  
  cat(sprintf("Alpine skier age range: %.0f - %.0f\n", min(elo_df$Age, na.rm = TRUE), max(elo_df$Age, na.rm = TRUE)))
}
```

**Purpose**: Performs comprehensive final validation to ensure data quality and logical consistency.

**Validation Checks**:
- **Infinite Value Detection**: Identifies any infinite or NaN values that could break models
- **Age Range Validation**: Ensures athlete ages are within reasonable bounds (15-50 years)
- **Finite Value Verification**: Confirms all numeric values are finite and usable

**Quality Standards**:
- **Model Readiness**: Ensures data is ready for machine learning algorithms
- **Logical Consistency**: Validates that data relationships make sense
- **Error Prevention**: Catches data quality issues before they affect downstream analysis

#### 8. Cross-Dataset Processing and Analysis
```r
# Prepare alpine ELO data for both men and ladies with comprehensive validation
cat("\n=== PREPARING MEN'S ALPINE ELO DATA ===\n")
tryCatch({
  M_elo <- prepare_alpine_elo_data(M_processed, "Men's")
}, error = function(e) {
  stop("Failed to prepare men's alpine ELO data: ", e$message)
})

cat("\n=== PREPARING LADIES ALPINE ELO DATA ===\n")
tryCatch({
  L_elo <- prepare_alpine_elo_data(L_processed, "Ladies")
}, error = function(e) {
  stop("Failed to prepare ladies alpine ELO data: ", e$message)
})

# Cross-validation between alpine ELO datasets
cat("\n=== CROSS-DATASET ALPINE ELO VALIDATION ===\n")

# Compare season ranges
men_elo_seasons <- sort(unique(M_elo$Season))
ladies_elo_seasons <- sort(unique(L_elo$Season))

cat("Men's alpine ELO seasons:", paste(range(men_elo_seasons), collapse = " - "), "(", length(men_elo_seasons), "seasons )\n")
cat("Ladies alpine ELO seasons:", paste(range(ladies_elo_seasons), collapse = " - "), "(", length(ladies_elo_seasons), "seasons )\n")

# Check for season overlap
common_elo_seasons <- intersect(men_elo_seasons, ladies_elo_seasons)
cat("Common alpine ELO seasons:", length(common_elo_seasons), "\n")

if (length(common_elo_seasons) == 0) {
  warning("No common seasons between men's and ladies alpine ELO data")
}
```

**Purpose**: Applies ELO preparation to both men's and women's data with comprehensive cross-validation.

**Processing Features**:
- **Parallel Processing**: Applies same preparation function to both datasets
- **Error Isolation**: Isolates processing errors to specific datasets
- **Season Coverage Comparison**: Validates temporal coverage between men's and women's data
- **Overlap Analysis**: Ensures adequate common seasons for comparative modeling

#### 9. Alpine ELO Distribution Analysis
```r
# Validate alpine ELO distributions
cat("\n--- Alpine ELO Distribution Analysis ---\n")

# Check ELO ranges for men
if ("Prev_Pelo" %in% names(M_elo)) {
  men_pelo_range <- range(M_elo$Prev_Pelo, na.rm = TRUE)
  cat(sprintf("Men's Prev_Pelo range: %.0f - %.0f\n", men_pelo_range[1], men_pelo_range[2]))
}

if ("Prev_Tech" %in% names(M_elo)) {
  men_tech_range <- range(M_elo$Prev_Tech, na.rm = TRUE)
  cat(sprintf("Men's Prev_Tech range: %.0f - %.0f\n", men_tech_range[1], men_tech_range[2]))
}

if ("Prev_Speed" %in% names(M_elo)) {
  men_speed_range <- range(M_elo$Prev_Speed, na.rm = TRUE)
  cat(sprintf("Men's Prev_Speed range: %.0f - %.0f\n", men_speed_range[1], men_speed_range[2]))
}
```

**Purpose**: Analyzes ELO rating distributions to validate data quality and identify potential issues.

**Distribution Analysis**:
- **Overall Alpine ELO**: General alpine skiing ability ratings
- **Technical Disciplines**: Slalom and Giant Slalom combined ratings
- **Speed Disciplines**: Downhill and Super G combined ratings
- **Range Validation**: Ensures ELO ranges are reasonable and consistent

### Alpine ELO-Specific Design Considerations

#### Multi-Discipline ELO Structure
Alpine skiing's unique characteristic is having separate ELO ratings for each discipline:
- **Individual Discipline Ratings**: Separate ELO for Downhill, Super G, Giant Slalom, Slalom, Combined
- **Aggregate Category Ratings**: Technical (Slalom + Giant Slalom) and Speed (Downhill + Super G)
- **Overall Alpine Rating**: General alpine skiing ability across all disciplines

#### Offseason Data Focus
ELO preparation specifically targets offseason data:
- **End-of-Season Ratings**: Represents final ELO after all season races completed
- **Stable Performance Indicators**: ELO ratings have stabilized by offseason
- **Predictive Value**: End-of-season ratings are most predictive of next season performance

#### Conservative Missing Value Treatment
The quartile-based imputation strategy:
- **Conservative Estimates**: First quartile provides conservative performance expectations
- **Season-Aware**: Imputation respects seasonal competitive context
- **Discipline-Specific**: Each alpine discipline gets independent treatment
- **Graceful Degradation**: Handles edge cases with appropriate fallback strategies

### Error Handling and Quality Assurance
- **Input Validation**: Comprehensive checks for data availability and structure
- **ELO Column Validation**: Flexible handling of missing discipline-specific ELO columns
- **Missing Value Monitoring**: Detailed tracking of missing value treatment effectiveness
- **Cross-Dataset Consistency**: Ensures consistent processing across men's and women's data
- **Distribution Validation**: Analyzes ELO distributions for quality assurance

This alpine ELO preparation section creates a robust foundation for machine learning models by providing clean, validated, and properly engineered features that respect alpine skiing's multi-discipline competitive structure and seasonal dynamics.

## Section: {r comprehensive-feature-selection} - Alpine Feature Selection & Model Optimization

### Purpose
This section implements comprehensive feature selection for alpine skiing season prediction using multiple statistical and machine learning methods. It identifies the most predictive alpine-specific features across all disciplines and creates robust consensus-based feature sets for both men's and women's modeling.

### Implementation Details

#### 1. Training Data Preparation and Validation
```r
cat("=== COMPREHENSIVE ALPINE FEATURE SELECTION & VALIDATION ===\n")

# Input validation for alpine ELO datasets
if (nrow(M_elo) == 0) {
  stop("Men's alpine ELO dataset is empty")
}
if (nrow(L_elo) == 0) {
  stop("Ladies alpine ELO dataset is empty")
}

cat(sprintf("Input alpine datasets: Men %d rows, Ladies %d rows\n", nrow(M_elo), nrow(L_elo)))

# Prepare training data - include more historical seasons to capture early breakthroughs
# Use data from 2016+ to include breakthrough seasons in alpine
cat("Filtering alpine training data (2016-2025, non-NA Pct_of_Max_Points)...\n")

# Check available seasons before filtering
men_seasons_available <- sort(unique(M_elo$Season))
ladies_seasons_available <- sort(unique(L_elo$Season))

cat(sprintf("Men's alpine available seasons: %s\n", paste(range(men_seasons_available), collapse = " - ")))
cat(sprintf("Ladies alpine available seasons: %s\n", paste(range(ladies_seasons_available), collapse = " - ")))

# Apply training filters with validation
train_men <- M_elo %>% 
  filter(Season <= 2025, Season >= 2016) %>% 
  filter(!is.na(Pct_of_Max_Points))

train_ladies <- L_elo %>% 
  filter(Season <= 2025, Season >= 2016) %>% 
  filter(!is.na(Pct_of_Max_Points))
```

**Purpose**: Establishes comprehensive training datasets with validated temporal coverage for alpine skiing feature selection.

**Training Data Strategy**:
- **Historical Coverage**: Uses 2016-2025 data to capture full range of alpine performance patterns
- **Target Variable Validation**: Ensures non-missing percentage of maximum points for supervised learning
- **Season Range Validation**: Confirms adequate temporal coverage for robust feature selection
- **Breakthrough Inclusion**: 2016+ timeframe captures early career breakthroughs in alpine skiing

**Quality Assurance**:
- **Empty Dataset Protection**: Prevents feature selection with insufficient data
- **Season Coverage Reporting**: Validates temporal span of training data
- **Model Robustness Check**: Warns if fewer than 3 seasons available

#### 2. Alpine Feature Definition and Availability Validation
```r
# Define and validate potential alpine features
cat("\n--- Alpine Feature Validation ---\n")

all_features <- c("Prev_Pelo", "Prev_Downhill", "Prev_Super_G", "Prev_Giant_Slalom", 
                  "Prev_Slalom", "Prev_Combined", "Prev_Tech", "Prev_Speed", 
                  "Prev_Pct_of_Max_Points", "Age")

# Check feature availability in alpine training datasets
men_available_features <- intersect(all_features, names(train_men))
ladies_available_features <- intersect(all_features, names(train_ladies))

cat(sprintf("Men's available alpine features: %d/%d\n", length(men_available_features), length(all_features)))
cat(sprintf("Ladies available alpine features: %d/%d\n", length(ladies_available_features), length(all_features)))

# Report missing features
men_missing_features <- setdiff(all_features, men_available_features)
ladies_missing_features <- setdiff(all_features, ladies_available_features)

if (length(men_missing_features) > 0) {
  cat("Men's missing alpine features:", paste(men_missing_features, collapse = ", "), "\n")
  warning("Some alpine features missing from men's training data")
}
if (length(ladies_missing_features) > 0) {
  cat("Ladies missing alpine features:", paste(ladies_missing_features, collapse = ", "), "\n")
  warning("Some alpine features missing from ladies training data")
}
```

**Purpose**: Validates availability of alpine-specific predictive features and handles graceful degradation for missing features.

**Alpine Feature Set**:
- **Overall Alpine Performance**: `Prev_Pelo` (previous season overall ELO)
- **Individual Discipline ELOs**: `Prev_Downhill`, `Prev_Super_G`, `Prev_Giant_Slalom`, `Prev_Slalom`, `Prev_Combined`
- **Discipline Category ELOs**: `Prev_Tech` (technical disciplines), `Prev_Speed` (speed disciplines)
- **Performance History**: `Prev_Pct_of_Max_Points` (previous season success rate)
- **Athlete Demographics**: `Age` (current age for experience modeling)

**Flexible Processing**:
- **Graceful Degradation**: Continues with available features if some are missing
- **Minimum Threshold**: Requires at least 3 features for meaningful feature selection
- **Cross-Gender Validation**: Ensures consistent feature availability across men's and women's data

#### 3. Data Quality Validation for Feature Selection
```r
# Validate alpine feature data quality
cat("\n--- Alpine Feature Data Quality Checks ---\n")

# Check for missing values in alpine features
men_feature_na_counts <- sapply(train_men[all_features_men], function(x) sum(is.na(x)))
ladies_feature_na_counts <- sapply(train_ladies[all_features_ladies], function(x) sum(is.na(x)))

if (any(men_feature_na_counts > 0)) {
  cat("Men's alpine features with NAs:\n")
  print(men_feature_na_counts[men_feature_na_counts > 0])
  warning("Men's alpine training data contains missing values in features")
}

# Check for infinite values
men_feature_inf_counts <- sapply(train_men[all_features_men], function(x) sum(!is.finite(x)))
ladies_feature_inf_counts <- sapply(train_ladies[all_features_ladies], function(x) sum(!is.finite(x)))

# Check target variable quality
men_target_na <- sum(is.na(train_men$Pct_of_Max_Points))
ladies_target_na <- sum(is.na(train_ladies$Pct_of_Max_Points))

cat(sprintf("Alpine target variable ranges: Men %.3f-%.3f, Ladies %.3f-%.3f\n",
            min(train_men$Pct_of_Max_Points, na.rm = TRUE), max(train_men$Pct_of_Max_Points, na.rm = TRUE),
            min(train_ladies$Pct_of_Max_Points, na.rm = TRUE), max(train_ladies$Pct_of_Max_Points, na.rm = TRUE)))
```

**Purpose**: Ensures data quality standards necessary for reliable feature selection across alpine skiing datasets.

**Quality Validation Checks**:
- **Missing Value Detection**: Identifies features with incomplete data that could bias selection
- **Infinite Value Detection**: Finds numerical issues that could break feature selection algorithms
- **Target Variable Validation**: Ensures target variable (percentage of maximum points) has valid range
- **Cross-Dataset Consistency**: Validates data quality across men's and women's datasets

#### 4. Multi-Method Feature Selection Framework

##### 4a. Correlation Analysis
```r
# 1. CORRELATION ANALYSIS with validation
cat("1. ALPINE CORRELATION ANALYSIS:\n")
tryCatch({
  if (length(all_features_men) < 2) {
    cat("Insufficient alpine features for correlation analysis\n")
    cor_matrix_men <- NULL
    high_cor_men <- data.frame()
  } else {
    cor_matrix_men <- cor(train_men[all_features_men], use = "complete.obs")
    
    # Validate correlation matrix
    if (any(is.na(cor_matrix_men))) {
      warning("Alpine correlation matrix contains NA values")
    }
    
    high_cor_men <- which(abs(cor_matrix_men) > 0.7 & upper.tri(cor_matrix_men), arr.ind = TRUE)
    if(nrow(high_cor_men) > 0) {
      cat("High alpine correlations (|r| > 0.7):\n")
      for(i in 1:nrow(high_cor_men)) {
        row_name <- rownames(cor_matrix_men)[high_cor_men[i,1]]
        col_name <- colnames(cor_matrix_men)[high_cor_men[i,2]]
        cor_val <- cor_matrix_men[high_cor_men[i,1], high_cor_men[i,2]]
        cat(sprintf("  %s - %s: %.3f\n", row_name, col_name, cor_val))
      }
    } else {
      cat("✓ No high alpine correlations found\n")
    }
  }
}, error = function(e) {
  cat("Error in alpine correlation analysis:", e$message, "\n")
  cor_matrix_men <- NULL
  high_cor_men <- data.frame()
})
```

**Purpose**: Identifies multicollinearity among alpine features and establishes baseline correlation patterns.

**Correlation Analysis Features**:
- **Multicollinearity Detection**: Identifies features with |r| > 0.7 that may cause modeling issues
- **Alpine-Specific Patterns**: Reveals relationships between different alpine disciplines
- **Quality Assurance**: Validates correlation matrix integrity and handles edge cases
- **Baseline Establishment**: Provides correlation foundation for other selection methods

##### 4b. LASSO Regularization
```r
# 2. LASSO REGULARIZATION with validation
cat("2. ALPINE LASSO REGULARIZATION:\n")
lasso_selected_men <- character(0)
tryCatch({
  set.seed(42)
  
  # Prepare data for LASSO
  x_men <- as.matrix(train_men[all_features_men])
  y_men <- train_men$Pct_of_Max_Points
  
  # Validate data for LASSO
  if (any(!is.finite(x_men))) {
    warning("Non-finite values in alpine feature matrix for LASSO")
  }
  if (any(!is.finite(y_men))) {
    warning("Non-finite values in alpine target variable for LASSO")
  }
  
  cv_lasso_men <- cv.glmnet(x_men, y_men, alpha = 1, nfolds = 5)
  best_lambda_men <- cv_lasso_men$lambda.min
  lasso_coef_men <- coef(cv_lasso_men, s = best_lambda_men)
  
  lasso_selected_men <- rownames(lasso_coef_men)[which(lasso_coef_men != 0)][-1]  # Remove intercept
  
  if (length(lasso_selected_men) > 0) {
    cat("Alpine LASSO selected features:\n")
    for (feature in lasso_selected_men) {
      coef_val <- lasso_coef_men[feature, 1]
      cat(sprintf("  %s: %.4f\n", feature, coef_val))
    }
  } else {
    cat("✓ No features selected by alpine LASSO (may indicate weak predictors)\n")
  }
  
  cat(sprintf("Best lambda: %.6f\n", best_lambda_men))
  
}, error = function(e) {
  cat("Error in alpine LASSO analysis:", e$message, "\n")
  lasso_selected_men <- character(0)
})
```

**Purpose**: Uses L1 regularization to identify alpine features that contribute most to prediction accuracy while preventing overfitting.

**LASSO Selection Features**:
- **Automatic Feature Selection**: LASSO naturally selects most predictive alpine features
- **Overfitting Prevention**: L1 regularization reduces model complexity for alpine data
- **Cross-Validation**: 5-fold CV optimizes lambda parameter for alpine-specific patterns
- **Coefficient Reporting**: Shows feature importance magnitude and direction
- **Reproducibility**: Fixed random seed ensures consistent results across runs

##### 4c. Boruta Feature Selection
```r
# 3. BORUTA FEATURE SELECTION with validation
cat("3. ALPINE BORUTA FEATURE SELECTION:\n")
boruta_selected_men <- character(0)
tryCatch({
  if (length(all_features_men) < 2) {
    cat("Insufficient alpine features for Boruta analysis\n")
  } else {
    set.seed(42)
    boruta_men <- Boruta(as.formula(paste("Pct_of_Max_Points ~", paste(all_features_men, collapse = " + "))), 
                         data = train_men, doTrace = 0)
    
    boruta_selected_men <- names(boruta_men$finalDecision)[boruta_men$finalDecision == "Confirmed"]
    
    if (length(boruta_selected_men) > 0) {
      cat("Alpine Boruta confirmed features:\n")
      for (feature in boruta_selected_men) {
        cat(sprintf("  %s\n", feature))
      }
    } else {
      cat("✓ No features confirmed by alpine Boruta\n")
    }
    
    # Check for tentative features
    tentative_men <- names(boruta_men$finalDecision)[boruta_men$finalDecision == "Tentative"]
    if (length(tentative_men) > 0) {
      cat("Alpine Boruta tentative features:\n")
      for (feature in tentative_men) {
        cat(sprintf("  %s (tentative)\n", feature))
      }
    }
  }
}, error = function(e) {
  cat("Error in alpine Boruta analysis:", e$message, "\n")
  boruta_selected_men <- character(0)
})
```

**Purpose**: Uses random forest-based all-relevant feature selection to identify all alpine features that have genuine predictive value.

**Boruta Selection Features**:
- **All-Relevant Selection**: Identifies all genuinely useful alpine features, not just best subset
- **Statistical Rigor**: Uses permutation testing to validate feature importance against random chance
- **Random Forest Foundation**: Leverages ensemble method strengths for alpine data patterns
- **Tentative Feature Handling**: Provides uncertainty quantification for borderline alpine features
- **Robust to Interactions**: Captures complex relationships between alpine disciplines

##### 4d. Exhaustive Search
```r
# 4. EXHAUSTIVE SEARCH with validation
cat("4. ALPINE EXHAUSTIVE SEARCH:\n")
leaps_selected_men <- character(0)
tryCatch({
  if (length(all_features_men) < 2) {
    cat("Insufficient alpine features for exhaustive search\n")
  } else if (length(all_features_men) > 8) {
    cat("Too many alpine features for exhaustive search - using best subset\n")
    leaps_men <- regsubsets(as.formula(paste("Pct_of_Max_Points ~", paste(all_features_men, collapse = " + "))), 
                           data = train_men, nvmax = min(8, length(all_features_men)))
  } else {
    leaps_men <- regsubsets(as.formula(paste("Pct_of_Max_Points ~", paste(all_features_men, collapse = " + "))), 
                           data = train_men, really.big = TRUE)
  }
  
  if (exists("leaps_men")) {
    summary_leaps_men <- summary(leaps_men)
    best_model_size <- which.max(summary_leaps_men$adjr2)
    leaps_selected_men <- names(which(summary_leaps_men$which[best_model_size, -1]))  # Remove intercept
    
    if (length(leaps_selected_men) > 0) {
      cat("Alpine exhaustive search selected features (best adj R²):\n")
      for (feature in leaps_selected_men) {
        cat(sprintf("  %s\n", feature))
      }
      cat(sprintf("Best model size: %d features, Adj R²: %.4f\n", 
                  best_model_size, summary_leaps_men$adjr2[best_model_size]))
    } else {
      cat("✓ No features selected by alpine exhaustive search\n")
    }
  }
}, error = function(e) {
  cat("Error in alpine exhaustive search:", e$message, "\n")
  leaps_selected_men <- character(0)
})
```

**Purpose**: Performs exhaustive search for optimal alpine feature combinations using adjusted R-squared optimization.

**Exhaustive Search Features**:
- **Optimal Subset Identification**: Finds best alpine feature combination for linear prediction
- **Adjusted R² Optimization**: Balances model fit with complexity for alpine data
- **Computational Efficiency**: Limits search to 8 features when full search impractical
- **Model Size Reporting**: Provides transparency about selected model complexity
- **Linear Relationship Focus**: Optimized for linear relationships in alpine performance data

#### 5. Consensus Feature Selection and Final Integration
```r
# 5. CONSENSUS FEATURE SELECTION
cat("5. ALPINE CONSENSUS FEATURE SELECTION:\n")

all_selected_men <- c(lasso_selected_men, boruta_selected_men, leaps_selected_men)
if (length(all_selected_men) > 0) {
  feature_counts_men <- table(all_selected_men)
  consensus_men <- names(feature_counts_men)[feature_counts_men >= 2]  # Features selected by 2+ methods
  
  if (length(consensus_men) > 0) {
    cat("Alpine consensus features (selected by 2+ methods):\n")
    for (feature in consensus_men) {
      count <- feature_counts_men[feature]
      methods <- c(
        if (feature %in% lasso_selected_men) "LASSO" else NULL,
        if (feature %in% boruta_selected_men) "Boruta" else NULL,
        if (feature %in% leaps_selected_men) "Exhaustive" else NULL
      )
      cat(sprintf("  %s (%d methods: %s)\n", feature, count, paste(methods, collapse = ", ")))
    }
  } else {
    cat("No alpine consensus features - using union of all methods\n")
    consensus_men <- unique(all_selected_men)
  }
} else {
  cat("No features selected by any method - using top correlated features\n")
  if (!is.null(cor_matrix_men) && "Pct_of_Max_Points" %in% names(train_men)) {
    target_cors <- cor(train_men[all_features_men], train_men$Pct_of_Max_Points, use = "complete.obs")
    consensus_men <- names(sort(abs(target_cors), decreasing = TRUE))[1:min(3, length(all_features_men))]
  } else {
    consensus_men <- all_features_men[1:min(3, length(all_features_men))]
  }
}

final_features_men <- consensus_men
cat(sprintf("Final alpine features for men: %s\n", paste(final_features_men, collapse = ", ")))
```

**Purpose**: Integrates results from multiple feature selection methods to create robust, consensus-based feature sets for alpine skiing prediction.

**Consensus Strategy**:
- **Multi-Method Integration**: Combines LASSO, Boruta, and exhaustive search results
- **Robust Selection**: Prioritizes features selected by 2+ methods for reliability
- **Fallback Mechanisms**: Uses union of methods or correlation-based selection when consensus fails
- **Method Transparency**: Reports which methods selected each consensus feature
- **Quality Assurance**: Ensures at least some features selected for model building

#### 6. Cross-Gender Feature Selection Replication
The same comprehensive feature selection process is applied to women's alpine data:

```r
cat("\n=== COMPREHENSIVE ALPINE FEATURE SELECTION FOR LADIES ===\n")

# Repeat the same process for ladies with alpine-specific adaptations
# 1. CORRELATION ANALYSIS
# 2. LASSO REGULARIZATION  
# 3. BORUTA FEATURE SELECTION
# 4. EXHAUSTIVE SEARCH
# 5. CONSENSUS FEATURE SELECTION
```

**Purpose**: Ensures consistent and thorough feature selection across both men's and women's alpine skiing datasets.

**Cross-Gender Consistency**:
- **Parallel Processing**: Applies identical methodology to both datasets
- **Gender-Specific Optimization**: Allows for different optimal feature sets between men's and women's alpine skiing
- **Comparative Analysis**: Enables comparison of feature importance patterns across genders
- **Independent Validation**: Validates feature selection robustness across different athlete populations

#### 7. Feature Selection Results Storage and Summary
```r
cat("\n=== ALPINE FEATURE SELECTION SUMMARY ===\n")
cat(sprintf("Men's final alpine features (%d): %s\n", length(final_features_men), paste(final_features_men, collapse = ", ")))
cat(sprintf("Ladies final alpine features (%d): %s\n", length(final_features_ladies), paste(final_features_ladies, collapse = ", ")))

# Store feature selection results for later use
feature_selection_results_men <- list(
  lasso = lasso_selected_men,
  boruta = boruta_selected_men,
  exhaustive = leaps_selected_men,
  final = final_features_men
)

feature_selection_results_ladies <- list(
  lasso = lasso_selected_ladies,
  boruta = boruta_selected_ladies,
  exhaustive = leaps_selected_ladies,
  final = final_features_ladies
)

cat("\n=== COMPREHENSIVE ALPINE FEATURE SELECTION COMPLETE ===\n")
```

**Purpose**: Summarizes feature selection results and stores detailed outcomes for subsequent modeling and analysis.

**Results Documentation**:
- **Final Feature Sets**: Reports consensus features for both men's and women's alpine skiing
- **Method-Specific Results**: Preserves individual method results for analysis and debugging
- **Structured Storage**: Organizes results in lists for programmatic access in downstream modeling
- **Comprehensive Summary**: Provides clear overview of feature selection outcomes

### Alpine Feature Selection Design Considerations

#### Multi-Discipline Feature Space
Alpine skiing's unique feature requirements:
- **Discipline-Specific ELOs**: Individual ratings for Downhill, Super G, Giant Slalom, Slalom, Combined
- **Aggregate Category Features**: Technical vs Speed discipline groupings
- **Performance History**: Previous season success metrics and trend indicators
- **Demographic Factors**: Age and experience considerations

#### Method Complementarity
The multi-method approach leverages different selection strengths:
- **LASSO**: Linear relationship optimization with automatic feature selection
- **Boruta**: All-relevant features with statistical rigor and interaction capture
- **Exhaustive Search**: Optimal subset identification for linear prediction
- **Consensus Integration**: Robust feature sets through method agreement

#### Alpine-Specific Adaptations
- **Season-Aware Training**: Uses 2016-2025 timeframe for modern alpine competitive dynamics
- **Discipline Balance**: Ensures representation across alpine's diverse competitive structure
- **Performance Standardization**: Works with percentage of maximum points for cross-season comparability
- **Gender-Specific Optimization**: Allows for different optimal features between men's and women's alpine skiing

### Error Handling and Quality Assurance
- **Input Validation**: Comprehensive checks for data availability and quality
- **Method-Specific Validation**: Individual error handling for each selection method
- **Consensus Robustness**: Multiple fallback strategies when consensus fails
- **Cross-Dataset Consistency**: Parallel processing ensures consistent methodology
- **Results Documentation**: Detailed tracking of selection outcomes and method performance

This alpine feature selection section creates optimized, statistically validated feature sets that capture the most predictive aspects of alpine skiing performance while maintaining robustness across different modeling approaches and athlete populations.

## Section: {r gam-model} - Alpine GAM Model Building & Prediction

### Purpose
This section builds Generalized Additive Models (GAM) for alpine skiing season prediction using consensus-selected features, validates model performance, and generates 2026 season predictions with comprehensive error handling and diagnostic evaluation.

### Implementation Details

#### 1. GAM Model Construction and Input Validation
```r
cat("=== GAM MODEL BUILDING & VALIDATION ===\n")

# Build GAM models using consensus-selected features with comprehensive validation
cat("\n--- GAM Model Construction ---\n")

# Validate inputs for GAM model building
if (!exists("final_features_men") || !exists("final_features_ladies")) {
  stop("Final features not defined - ensure feature selection completed successfully")
}

if (!exists("train_men") || !exists("train_ladies")) {
  stop("Training data not available - ensure data preparation completed successfully")
}

cat(sprintf("Input validation: Men %d features, Ladies %d features\n", 
            length(final_features_men), length(final_features_ladies)))

cat(sprintf("Training data: Men %d rows, Ladies %d rows\n", 
            nrow(train_men), nrow(train_ladies)))
```

**Purpose**: Establishes comprehensive validation framework for GAM model construction using alpine-specific consensus features.

**Input Validation Features**:
- **Feature Availability Check**: Ensures consensus feature selection completed successfully
- **Training Data Validation**: Confirms processed training data is available for modeling
- **Data Size Reporting**: Reports feature counts and training dataset sizes for both genders
- **Dependency Verification**: Validates that prerequisite processing steps completed successfully

#### 2. Men's GAM Model Construction with Robust Error Handling
```r
# Build GAM formula for Men using validated features
cat("\n--- Men's GAM Model ---\n")
men_gam_model <- NULL
tryCatch({
  if(length(final_features_men) > 0) {
    # Validate features exist in training data
    missing_features_men <- setdiff(final_features_men, names(train_men))
    if (length(missing_features_men) > 0) {
      cat("Warning: Missing features in men's training data:", paste(missing_features_men, collapse = ", "), "\n")
      final_features_men <- intersect(final_features_men, names(train_men))
    }
    
    if (length(final_features_men) > 0) {
      smooth_terms_men <- paste("s(", final_features_men, ")", collapse = " + ")
      gam_formula_men <- as.formula(paste("Pct_of_Max_Points ~", smooth_terms_men))
      cat("Men's GAM Formula (Validated Features):\n")
      print(gam_formula_men)
      
      # Check for sufficient data points per feature
      min_obs_per_feature <- 10
      required_obs <- length(final_features_men) * min_obs_per_feature
      if (nrow(train_men) < required_obs) {
        warning(sprintf("Limited observations for men's GAM (%d obs, %d features, recommend %d+ obs)", 
                       nrow(train_men), length(final_features_men), required_obs))
      }
      
      # Build GAM with error handling
      men_gam_model <- gam(gam_formula_men, data = train_men)
      cat(sprintf("✓ Men's GAM model built successfully with %d features\n", length(final_features_men)))
    }
  }
}, error = function(e) {
  cat("Error building men's GAM model:", e$message, "\n")
  cat("Attempting fallback to core features...\n")
  
  # Fallback to proven core features
  core_features_men <- intersect(c("Prev_Pct_of_Max_Points", "Prev_Pelo", "Prev_Tech", "Prev_Speed"), names(train_men))
  if (length(core_features_men) >= 2) {
    fallback_formula_men <- paste("Pct_of_Max_Points ~", paste("s(", core_features_men, ")", collapse = " + "))
    men_gam_model <- gam(as.formula(fallback_formula_men), data = train_men)
    final_features_men <- core_features_men
    cat("✓ Men's GAM fallback model built with core features\n")
  } else {
    stop("Cannot build men's GAM model - insufficient core features available")
  }
})
```

**Purpose**: Constructs robust GAM models for men's alpine skiing with comprehensive error handling and fallback strategies.

**GAM Construction Features**:
- **Feature Validation**: Confirms selected features exist in training data before model building
- **Formula Generation**: Creates GAM formula with smooth terms for non-linear relationships
- **Data Sufficiency Check**: Validates adequate observations per feature (10:1 ratio recommended)
- **Smooth Term Integration**: Uses `s()` notation for capturing non-linear alpine performance relationships
- **Robust Error Handling**: Implements fallback to core alpine features when consensus features fail

**Fallback Strategy**:
- **Core Features**: Falls back to proven alpine predictors (Prev_Pct_of_Max_Points, Prev_Pelo, Prev_Tech, Prev_Speed)
- **Minimum Requirements**: Requires at least 2 core features for fallback model
- **Graceful Degradation**: Ensures model building succeeds even with limited feature availability

#### 3. Ladies GAM Model Construction with Parallel Processing
```r
# Build GAM formula for Ladies using validated features
cat("\n--- Ladies GAM Model ---\n")
ladies_gam_model <- NULL
tryCatch({
  if(length(final_features_ladies) > 0) {
    # Validate features exist in training data
    missing_features_ladies <- setdiff(final_features_ladies, names(train_ladies))
    if (length(missing_features_ladies) > 0) {
      cat("Warning: Missing features in ladies training data:", paste(missing_features_ladies, collapse = ", "), "\n")
      final_features_ladies <- intersect(final_features_ladies, names(train_ladies))
    }
    
    if (length(final_features_ladies) > 0) {
      smooth_terms_ladies <- paste("s(", final_features_ladies, ")", collapse = " + ")
      gam_formula_ladies <- as.formula(paste("Pct_of_Max_Points ~", smooth_terms_ladies))
      cat("Ladies GAM Formula (Validated Features):\n")
      print(gam_formula_ladies)
      
      # Check for sufficient data points per feature
      min_obs_per_feature <- 10
      required_obs <- length(final_features_ladies) * min_obs_per_feature
      if (nrow(train_ladies) < required_obs) {
        warning(sprintf("Limited observations for ladies GAM (%d obs, %d features, recommend %d+ obs)", 
                       nrow(train_ladies), length(final_features_ladies), required_obs))
      }
      
      # Build GAM with error handling
      ladies_gam_model <- gam(gam_formula_ladies, data = train_ladies)
      cat(sprintf("✓ Ladies GAM model built successfully with %d features\n", length(final_features_ladies)))
    }
  }
}, error = function(e) {
  cat("Error building ladies GAM model:", e$message, "\n")
  cat("Attempting fallback to core features...\n")
  
  # Fallback to proven core features
  core_features_ladies <- intersect(c("Prev_Pct_of_Max_Points", "Prev_Pelo", "Prev_Tech", "Prev_Speed"), names(train_ladies))
  if (length(core_features_ladies) >= 2) {
    fallback_formula_ladies <- paste("Pct_of_Max_Points ~", paste("s(", core_features_ladies, ")", collapse = " + "))
    ladies_gam_model <- gam(as.formula(fallback_formula_ladies), data = train_ladies)
    final_features_ladies <- core_features_ladies
    cat("✓ Ladies GAM fallback model built with core features\n")
  } else {
    stop("Cannot build ladies GAM model - insufficient core features available")
  }
})
```

**Purpose**: Constructs women's alpine GAM models using identical methodology to ensure cross-gender consistency and robustness.

**Parallel Processing Benefits**:
- **Consistent Methodology**: Uses same validation and construction process as men's models
- **Gender-Specific Optimization**: Allows for different optimal features between men's and women's alpine skiing
- **Independent Validation**: Validates model construction robustness across different athlete populations
- **Comparative Analysis**: Enables comparison of model performance patterns across genders

#### 4. Comprehensive GAM Model Performance Evaluation
```r
# Model performance evaluation with validation
cat("\n=== GAM MODEL PERFORMANCE EVALUATION ===\n")

# Men's GAM Model Performance
cat("--- Men's GAM Model Performance ---\n")
tryCatch({
  men_summary <- summary(men_gam_model)
  
  # Validate summary components exist
  if (is.null(men_summary$dev.expl)) {
    warning("Men's GAM deviance explained not available")
    men_dev_expl <- NA
  } else {
    men_dev_expl <- men_summary$dev.expl * 100
  }
  
  if (is.null(men_summary$r.sq)) {
    warning("Men's GAM R-squared not available")
    men_r_sq <- NA
  } else {
    men_r_sq <- men_summary$r.sq
  }
  
  if (is.null(men_gam_model$gcv.ubre)) {
    warning("Men's GAM GCV score not available")
    men_gcv <- NA
  } else {
    men_gcv <- men_gam_model$gcv.ubre
  }
  
  cat(sprintf("Deviance Explained: %.2f%%\n", men_dev_expl))
  cat(sprintf("Adjusted R-squared: %.3f\n", men_r_sq))
  cat(sprintf("GCV Score: %.4f\n", men_gcv))
  
  # Validate model performance
  if (!is.na(men_dev_expl) && men_dev_expl < 10) {
    warning("Men's GAM has very low deviance explained (<10%)")
  }
  if (!is.na(men_r_sq) && men_r_sq < 0.1) {
    warning("Men's GAM has very low R-squared (<0.1)")
  }
  
  # Model fit statistics
  cat(sprintf("Observations: %d\n", nrow(men_gam_model$model)))
  cat(sprintf("Effective degrees of freedom: %.1f\n", sum(men_gam_model$edf)))
  
}, error = function(e) {
  cat("Error evaluating men's GAM performance:", e$message, "\n")
})
```

**Purpose**: Provides comprehensive evaluation of GAM model performance using multiple alpine-specific metrics.

**Performance Metrics**:
- **Deviance Explained**: Measures how much variance the model explains in alpine performance data
- **Adjusted R-squared**: Accounts for model complexity in goodness-of-fit assessment
- **GCV Score**: Generalized Cross-Validation score for model selection and validation
- **Effective Degrees of Freedom**: Measures model complexity for alpine feature relationships

**Quality Validation**:
- **Performance Thresholds**: Warns if deviance explained <10% or R-squared <0.1
- **Component Validation**: Ensures all performance metrics are available and valid
- **Model Complexity Assessment**: Reports observations and effective degrees of freedom

#### 5. Feature Importance Analysis Through Effective Degrees of Freedom
```r
# Feature importance from GAM (edf values) with validation
cat("\n--- Feature Importance Analysis ---\n")

# Men's Feature Importance
cat("Men's GAM Feature Importance (Effective Degrees of Freedom):\n")
tryCatch({
  if (!is.null(men_summary$s.table) && nrow(men_summary$s.table) > 0) {
    men_edf <- men_summary$s.table[,"edf"]
    names(men_edf) <- rownames(men_summary$s.table)
    
    # Validate EDF values
    if (any(is.na(men_edf))) {
      warning("Some men's GAM EDF values are NA")
      men_edf <- men_edf[!is.na(men_edf)]
    }
    
    if (length(men_edf) > 0) {
      edf_sorted <- sort(men_edf, decreasing = TRUE)
      for (i in 1:length(edf_sorted)) {
        cat(sprintf("  %s: %.3f\n", names(edf_sorted)[i], edf_sorted[i]))
      }
      
      # Identify most complex features (high EDF suggests non-linear relationship)
      high_edf_features <- names(men_edf[men_edf > 3])
      if (length(high_edf_features) > 0) {
        cat("Features with non-linear relationships (EDF > 3):", paste(high_edf_features, collapse = ", "), "\n")
      }
    } else {
      cat("No valid EDF values for men's model\n")
    }
  } else {
    cat("No smooth terms in men's GAM model\n")
  }
}, error = function(e) {
  cat("Error analyzing men's feature importance:", e$message, "\n")
})
```

**Purpose**: Analyzes feature importance in alpine GAM models using Effective Degrees of Freedom to understand non-linear relationships.

**EDF Analysis Features**:
- **Non-linearity Detection**: High EDF values (>3) indicate strong non-linear relationships in alpine performance
- **Feature Ranking**: Sorts features by complexity to identify most important alpine predictors
- **Complexity Assessment**: EDF ≈1 suggests linear relationship, higher values indicate more complex curves
- **Alpine-Specific Interpretation**: Helps understand which alpine disciplines show non-linear performance patterns

#### 6. Comprehensive GAM Model Diagnostics
```r
# Model diagnostics with validation
cat("\n=== GAM MODEL DIAGNOSTICS ===\n")

# Men's GAM Model Diagnostics
cat("--- Men's GAM Model Diagnostics ---\n")
tryCatch({
  par(mfrow = c(2, 2))
  gam_check_men <- gam.check(men_gam_model, sub.caption = "Men's GAM Diagnostics")
  
  # Extract and validate diagnostic information
  if (!is.null(gam_check_men)) {
    # Check for model convergence issues
    if ("converged" %in% names(men_gam_model) && !men_gam_model$converged) {
      warning("Men's GAM model did not converge properly")
    }
    
    # Check basis dimensions
    if ("p.table" %in% names(men_summary)) {
      basis_dims <- men_summary$s.table[,"k-index"]
      low_basis <- names(basis_dims[basis_dims < 0.1])
      if (length(low_basis) > 0) {
        warning(paste("Men's GAM features with potentially insufficient basis dimensions:", 
                     paste(low_basis, collapse = ", ")))
      }
    }
  }
  
  cat("✓ Men's GAM diagnostic plots generated\n")
  
}, error = function(e) {
  cat("Error generating men's GAM diagnostics:", e$message, "\n")
  # Reset plotting parameters
  par(mfrow = c(1, 1))
})
```

**Purpose**: Generates comprehensive diagnostic plots and validates GAM model assumptions for alpine skiing data.

**Diagnostic Features**:
- **Residual Analysis**: QQ plots and residual vs fitted plots for assumption validation
- **Convergence Validation**: Checks if GAM optimization converged properly for alpine data
- **Basis Dimension Assessment**: Validates smooth function basis dimensions are adequate
- **Visual Diagnostics**: Four-panel diagnostic plots for comprehensive model validation

#### 7. 2026 Season Prediction Framework
```r
# Predict for 2026 season using 2025 ELO values with comprehensive validation
cat("\n=== 2026 SEASON PREDICTIONS ===\n")

# Validate prediction data availability
cat("--- Prediction Data Preparation ---\n")

# Check for 2025 ELO data (end-of-season values)
men_2025 <- M_elo %>% 
  filter(Season == 2025) %>%
  group_by(Skier) %>%
  slice_tail(n = 1) %>%  # Get most recent record per skier (end-of-2025)
  ungroup()

ladies_2025 <- L_elo %>% 
  filter(Season == 2025) %>%
  group_by(Skier) %>%
  slice_tail(n = 1) %>%  # Get most recent record per skier (end-of-2025)
  ungroup()

# Rename columns to match GAM model expectations (Prev_* format)
cat("Renaming 2025 features to Prev_* format for GAM predictions...\n")
```

**Purpose**: Establishes comprehensive framework for generating 2026 alpine skiing season predictions using trained GAM models.

**Prediction Data Preparation**:
- **End-of-Season ELO**: Uses most recent 2025 ELO ratings as predictors for 2026 performance
- **Feature Alignment**: Renames 2025 ELO columns to match GAM model expected format (Prev_*)
- **Data Validation**: Ensures prediction data availability and quality before GAM prediction
- **Temporal Consistency**: Maintains proper time ordering for prediction validity

#### 8. Data Preprocessing for 2026 Predictions
```r
if (nrow(men_2025) > 0) {
  # First, remove existing Prev_* columns (which contain 2024 data)
  prev_cols_to_remove <- c("Prev_Pelo", "Prev_Downhill", "Prev_Super_G", "Prev_Giant_Slalom", 
                          "Prev_Slalom", "Prev_Combined", "Prev_Tech", "Prev_Speed", "Prev_Pct_of_Max_Points")
  existing_prev_cols <- intersect(prev_cols_to_remove, names(men_2025))
  if (length(existing_prev_cols) > 0) {
    cat("Removing existing Prev_* columns (2024 data):", paste(existing_prev_cols, collapse = ", "), "\n")
    men_2025 <- men_2025 %>% dplyr::select(-all_of(existing_prev_cols))
  }
  
  # Then rename current 2025 columns to Prev_* format
  men_2025 <- men_2025 %>%
    rename(
      Prev_Pelo = Pelo,
      Prev_Downhill = Downhill_Pelo,
      Prev_Super_G = `Super G_Pelo`,
      Prev_Giant_Slalom = `Giant Slalom_Pelo`,
      Prev_Slalom = Slalom_Pelo,
      Prev_Combined = Combined_Pelo,
      Prev_Tech = Tech_Pelo,
      Prev_Speed = Speed_Pelo,
      Prev_Pct_of_Max_Points = Pct_of_Max_Points
    )
}

# Apply quartile replacement to handle missing values in 2025 data
cat("Applying quartile replacement for missing values in 2025 prediction data...\n")

if (nrow(men_2025) > 0) {
  men_2025 <- men_2025 %>%
    group_by(Season) %>%
    mutate(
      Prev_Pelo = replace_na_with_quartile(Prev_Pelo),
      Prev_Downhill = replace_na_with_quartile(Prev_Downhill),
      Prev_Super_G = replace_na_with_quartile(Prev_Super_G),
      Prev_Giant_Slalom = replace_na_with_quartile(Prev_Giant_Slalom),
      Prev_Slalom = replace_na_with_quartile(Prev_Slalom),
      Prev_Combined = replace_na_with_quartile(Prev_Combined),
      Prev_Tech = replace_na_with_quartile(Prev_Tech),
      Prev_Speed = replace_na_with_quartile(Prev_Speed),
      Prev_Pct_of_Max_Points = replace_na_with_quartile(Prev_Pct_of_Max_Points)
    ) %>%
    ungroup()
}
```

**Purpose**: Implements robust data preprocessing for 2026 predictions with comprehensive missing value handling.

**Preprocessing Steps**:
- **Legacy Data Removal**: Removes outdated Prev_* columns containing 2024 data
- **Feature Renaming**: Converts 2025 ELO ratings to Prev_* format for GAM model compatibility
- **Missing Value Imputation**: Applies conservative quartile-based imputation for missing alpine ELO values
- **Discipline-Specific Treatment**: Handles missing values for each alpine discipline independently

#### 9. GAM-Based 2026 Prediction Generation
```r
# Men's 2026 Predictions
cat("\n--- Men's 2026 Predictions ---\n")
men_pred_data <- NULL
if(nrow(men_2025) > 0) {
  tryCatch({
    # Validate features are available in 2025 data
    available_features_men <- intersect(final_features_men, names(men_2025))
    missing_features_men <- setdiff(final_features_men, names(men_2025))
    
    if (length(missing_features_men) > 0) {
      cat("Warning: Missing features in men's 2025 data for prediction:", paste(missing_features_men, collapse = ", "), "\n")
    }
    
    if (length(available_features_men) > 0) {
      # Debug: Show exact GAM model input for Marcel Hirscher
      if ("Marcel Hirscher" %in% men_2025$Skier) {
        hirscher_idx <- which(men_2025$Skier == "Marcel Hirscher")
        cat("\n=== DEBUG: Marcel Hirscher GAM Model Input ===\n")
        cat("Selected features for GAM:", paste(final_features_men, collapse = ", "), "\n")
        hirscher_model_data <- men_2025[hirscher_idx, c("Skier", final_features_men), drop = FALSE]
        print(hirscher_model_data)
      }
      
      # Use only available features for prediction
      pred_2026_men <- predict(men_gam_model, newdata = men_2025, se.fit = TRUE)
      
      # Validate predictions
      if (any(!is.finite(pred_2026_men$fit))) {
        warning("Some men's 2026 predictions are non-finite")
        pred_2026_men$fit[!is.finite(pred_2026_men$fit)] <- NA
      }
      
      men_pred_data <- men_2025 %>%
        mutate(
          Predicted_Pct_2026 = pred_2026_men$fit,
          Prediction_SE = pred_2026_men$se.fit,
          Lower_CI = Predicted_Pct_2026 - 1.96 * Prediction_SE,
          Upper_CI = Predicted_Pct_2026 + 1.96 * Prediction_SE
        ) %>%
        filter(!is.na(Predicted_Pct_2026)) %>%
        arrange(desc(Predicted_Pct_2026))
      
      cat(sprintf("✓ Men's 2026 predictions generated for %d athletes\n", nrow(men_pred_data)))
      cat(sprintf("Top predicted: %s (%.2f%% of max points)\n", 
                  men_pred_data$Skier[1], men_pred_data$Predicted_Pct_2026[1] * 100))
    }
  }, error = function(e) {
    cat("Error generating men's 2026 predictions:", e$message, "\n")
  })
}
```

**Purpose**: Generates 2026 season predictions with confidence intervals and comprehensive validation.

**Prediction Features**:
- **Feature Validation**: Ensures required features are available in 2025 prediction data
- **Debug Output**: Provides detailed model input for star athletes (Marcel Hirscher, Lara Colturi)
- **Uncertainty Quantification**: Generates standard errors and 95% confidence intervals
- **Prediction Validation**: Checks for non-finite predictions and handles gracefully
- **Results Ranking**: Sorts predictions by expected performance for easy interpretation

### Alpine GAM-Specific Design Considerations

#### Non-Linear Relationship Modeling
GAM models excel at capturing alpine skiing's complex performance patterns:
- **Smooth Functions**: Use spline smoothing to model non-linear relationships between ELO ratings and performance
- **Discipline Interactions**: Capture complex relationships between different alpine disciplines
- **Performance Curves**: Model diminishing returns and threshold effects in alpine performance
- **Age Effects**: Capture non-linear age-performance relationships in alpine skiing

#### Alpine-Specific Model Validation
- **EDF Interpretation**: High EDF values indicate complex non-linear relationships specific to alpine disciplines
- **Convergence Monitoring**: Ensures GAM optimization converges properly for alpine data patterns
- **Basis Dimension Validation**: Confirms adequate flexibility for modeling alpine performance curves
- **Cross-Gender Consistency**: Validates model construction robustness across different athlete populations

#### Prediction Robustness
- **Feature Alignment**: Ensures 2025 ELO data properly formatted for GAM prediction
- **Missing Value Handling**: Conservative quartile-based imputation maintains prediction reliability
- **Uncertainty Quantification**: Confidence intervals provide prediction reliability assessment
- **Star Athlete Debugging**: Detailed output for high-profile athletes ensures prediction transparency

### Error Handling and Quality Assurance
- **Comprehensive Input Validation**: Validates all prerequisites before GAM construction
- **Robust Fallback Strategies**: Core feature fallbacks ensure model building succeeds
- **Performance Monitoring**: Multiple metrics assess model quality and reliability
- **Prediction Validation**: Extensive checks ensure prediction quality and interpretability
- **Diagnostic Integration**: Built-in diagnostic plots validate model assumptions

This alpine GAM modeling section creates sophisticated, non-linear prediction models that capture the complex relationships inherent in alpine skiing performance while maintaining robustness and providing comprehensive uncertainty quantification for 2026 season predictions.

## Section: {r odds-setup} - Alpine Odds Framework & Categorical Outcome Preparation

### Purpose
This section establishes the comprehensive framework for odds calculation in alpine skiing by creating categorical performance outcomes, validating ranking systems, and preparing prediction data for statistical odds modeling across multiple performance thresholds.

### Implementation Details

#### 1. Training Data Validation for Odds Calculation
```r
cat("=== ODDS SETUP & VALIDATION ===\n")

# Validate training data availability for odds calculations
cat("\n--- Training Data Validation for Odds ---\n")

if (!exists("train_men") || !exists("train_ladies")) {
  stop("Training data not available - ensure previous sections completed successfully")
}

if (nrow(train_men) == 0) {
  stop("Men's training data is empty")
}
if (nrow(train_ladies) == 0) {
  stop("Ladies training data is empty") 
}

cat(sprintf("Training data for odds: Men %d rows, Ladies %d rows\n", nrow(train_men), nrow(train_ladies)))

# Validate required columns exist
required_odds_cols <- c("Pct_of_Max_Points", "Season")
missing_men_cols <- setdiff(required_odds_cols, names(train_men))
missing_ladies_cols <- setdiff(required_odds_cols, names(train_ladies))

if (length(missing_men_cols) > 0) {
  stop(sprintf("Men's training data missing required columns for odds: %s", paste(missing_men_cols, collapse = ", ")))
}
if (length(missing_ladies_cols) > 0) {
  stop(sprintf("Ladies training data missing required columns for odds: %s", paste(missing_ladies_cols, collapse = ", ")))
}
```

**Purpose**: Validates comprehensive training data availability and quality for alpine skiing odds calculation framework.

**Data Validation Features**:
- **Training Data Existence**: Confirms processed training data is available from previous sections
- **Empty Dataset Protection**: Prevents odds calculation with insufficient data
- **Required Column Validation**: Ensures essential variables (Pct_of_Max_Points, Season) are present
- **Cross-Gender Validation**: Validates data availability for both men's and women's alpine skiing

**Quality Assurance**:
- **Data Size Reporting**: Reports training dataset sizes for transparency
- **Dependency Verification**: Ensures prerequisite processing steps completed successfully
- **Error Prevention**: Stops processing if critical data components are missing

#### 2. Season-Based Ranking System Implementation
```r
# Add Place column based on rankings within each season with validation
cat("\n--- Season Ranking Calculation ---\n")

tryCatch({
  df_place <- train_men %>%
    group_by(Season) %>%
    mutate(Place = rank(-Pct_of_Max_Points, ties.method = "min")) %>%
    ungroup()
  
  cat(sprintf("✓ Men's place rankings calculated: %d rows\n", nrow(df_place)))
}, error = function(e) {
  stop("Failed to calculate men's place rankings: ", e$message)
})

tryCatch({
  df_place_ladies <- train_ladies %>%
    group_by(Season) %>%
    mutate(Place = rank(-Pct_of_Max_Points, ties.method = "min")) %>%
    ungroup()
    
  cat(sprintf("✓ Ladies place rankings calculated: %d rows\n", nrow(df_place_ladies)))
}, error = function(e) {
  stop("Failed to calculate ladies place rankings: ", e$message)
})

# Validate Place column creation
place_na_men <- sum(is.na(df_place$Place))
place_na_ladies <- sum(is.na(df_place_ladies$Place))

if (place_na_men > 0) {
  warning(sprintf("Men's Place column has %d NA values", place_na_men))
}
if (place_na_ladies > 0) {
  warning(sprintf("Ladies Place column has %d NA values", place_na_ladies))
}

# Validate ranking ranges
men_place_range <- range(df_place$Place, na.rm = TRUE)
ladies_place_range <- range(df_place_ladies$Place, na.rm = TRUE)

cat(sprintf("Men's Place range: %d - %d\n", men_place_range[1], men_place_range[2]))
cat(sprintf("Ladies Place range: %d - %d\n", ladies_place_range[1], ladies_place_range[2]))
```

**Purpose**: Implements robust season-based ranking system that creates competitive context for alpine skiing odds calculation.

**Ranking System Features**:
- **Season-Based Rankings**: Rankings calculated within each season to account for competitive context
- **Performance-Based Ordering**: Uses negative Pct_of_Max_Points for descending order (best performers ranked 1st)
- **Tie Handling**: Uses "min" method for consistent tie-breaking in alpine performance rankings
- **Cross-Gender Processing**: Applies identical ranking methodology to both men's and women's data

**Validation Framework**:
- **Missing Value Detection**: Identifies and reports any NA values in ranking calculations
- **Range Validation**: Confirms ranking ranges are logical (starting from 1)
- **Error Handling**: Robust error handling ensures ranking calculation succeeds or fails gracefully

#### 3. Comprehensive Season Ranking Validation
```r
# Debug and validate season rankings
cat("\n--- Season Ranking Validation ---\n")

# Check ladies data distribution
cat("Ladies Pct_of_Max_Points distribution:\n")
ladies_pct_summary <- summary(train_ladies$Pct_of_Max_Points)
print(ladies_pct_summary)

# Validate no negative or extreme values
if (any(train_ladies$Pct_of_Max_Points < 0, na.rm = TRUE)) {
  warning("Ladies data contains negative Pct_of_Max_Points values")
}
if (any(train_ladies$Pct_of_Max_Points > 2, na.rm = TRUE)) {
  warning("Ladies data contains very high Pct_of_Max_Points values (>200%)")
}

cat("Ladies Place distribution:\n")
ladies_place_table <- table(df_place_ladies$Place)
print(head(ladies_place_table, 10))

cat("Ladies seasons distribution:\n")
ladies_season_table <- table(df_place_ladies$Season)
print(ladies_season_table)

# Check for balanced season representation
if (any(ladies_season_table < 5)) {
  seasons_low_n <- names(ladies_season_table[ladies_season_table < 5])
  warning(sprintf("Ladies seasons with <5 observations: %s", paste(seasons_low_n, collapse = ", ")))
}

# Sample rankings validation
cat("Sample ladies season rankings (first 15):\n")
sample_rankings <- df_place_ladies %>% 
  arrange(Season, Place) %>% 
  dplyr::select(Season, Skier, Pct_of_Max_Points, Place) %>%
  head(15)
print(sample_rankings)
```

**Purpose**: Provides comprehensive validation of alpine skiing ranking system quality and distribution characteristics.

**Validation Components**:
- **Performance Distribution Analysis**: Examines Pct_of_Max_Points distribution for data quality
- **Extreme Value Detection**: Identifies negative or unrealistically high performance values
- **Ranking Distribution**: Analyzes place distribution to understand competitive structure
- **Season Balance Assessment**: Ensures adequate representation across all alpine skiing seasons
- **Sample Validation**: Provides concrete examples of ranking calculation results

**Quality Checks**:
- **Data Range Validation**: Confirms performance percentages are within expected bounds (0-200%)
- **Season Representation**: Warns about seasons with insufficient data (<5 observations)
- **Ranking Logic Verification**: Shows sample rankings to validate correct ordering

#### 4. Categorical Outcome Framework Creation
```r
# Create categorical outcomes for different cutoffs with validation
cat("\n--- Categorical Outcome Creation ---\n")

tryCatch({
  df_place <- df_place %>%
    mutate(
      Win = factor(ifelse(Place <= 1, 1, 0)),
      TopThree = factor(ifelse(Place <= 3, 1, 0)),  # Binary: 1=Top3, 0=Not Top3
      Top5 = factor(ifelse(Place <= 5, 1, 0)),
      Top10 = factor(ifelse(Place <= 10, 1, 0)),
      Top30 = factor(ifelse(Place <= 30, 1, 0))
    )
  
  cat("✓ Men's categorical outcomes created\n")
}, error = function(e) {
  stop("Failed to create men's categorical outcomes: ", e$message)
})

tryCatch({
  df_place_ladies <- df_place_ladies %>%
    mutate(
      Win = factor(ifelse(Place <= 1, 1, 0)),
      TopThree = factor(ifelse(Place <= 3, 1, 0)),  # Binary: 1=Top3, 0=Not Top3
      Top5 = factor(ifelse(Place <= 5, 1, 0)),
      Top10 = factor(ifelse(Place <= 10, 1, 0)),
      Top30 = factor(ifelse(Place <= 30, 1, 0))
    )
  
  cat("✓ Ladies categorical outcomes created\n")
}, error = function(e) {
  stop("Failed to create ladies categorical outcomes: ", e$message)
})
```

**Purpose**: Creates comprehensive categorical outcome framework for alpine skiing odds calculation across multiple performance thresholds.

**Categorical Outcome Structure**:
- **Win**: Season victory (Place <= 1) - captures championship-level performance
- **TopThree**: Podium finish (Place <= 3) - represents elite consistency in alpine skiing
- **Top5**: Elite performance (Place <= 5) - broader elite tier for alpine competitive analysis
- **Top10**: Strong performance (Place <= 10) - competitive alpine skiing threshold
- **Top30**: Points-scoring finish (Place <= 30) - alpine World Cup points eligibility

**Alpine-Specific Considerations**:
- **Championship Focus**: Win category captures seasonal dominance in alpine skiing
- **Podium Emphasis**: TopThree aligns with alpine skiing's podium ceremony tradition
- **Points Threshold**: Top30 corresponds to alpine World Cup points system (top 30 score points)
- **Factor Encoding**: Binary factors (0/1) enable logistic regression modeling for odds calculation

#### 5. Comprehensive Categorical Outcome Validation
```r
# Validate categorical outcome creation
cat("\n--- Categorical Outcome Validation ---\n")

# Check TopThree creation for ladies
cat("Ladies Place vs TopThree validation:\n")
topthree_crosstab <- table(df_place_ladies$Place, df_place_ladies$TopThree, useNA = "always")
print(topthree_crosstab[1:min(10, nrow(topthree_crosstab)), ])

# Validate factor levels
expected_levels <- c("0", "1")
targets <- c("Win", "TopThree", "Top5", "Top10", "Top30")

for (target in targets) {
  men_levels <- levels(df_place[[target]])
  ladies_levels <- levels(df_place_ladies[[target]])
  
  if (!all(expected_levels %in% men_levels)) {
    warning(sprintf("Men's %s missing expected levels: %s", target, paste(setdiff(expected_levels, men_levels), collapse = ", ")))
  }
  if (!all(expected_levels %in% ladies_levels)) {
    warning(sprintf("Ladies %s missing expected levels: %s", target, paste(setdiff(expected_levels, ladies_levels), collapse = ", ")))
  }
  
  # Check for class imbalance
  men_table <- table(df_place[[target]])
  ladies_table <- table(df_place_ladies[[target]])
  
  men_minority_pct <- min(men_table) / sum(men_table) * 100
  ladies_minority_pct <- min(ladies_table) / sum(ladies_table) * 100
  
  cat(sprintf("%s class balance: Men %.1f%% minority, Ladies %.1f%% minority\n", 
              target, men_minority_pct, ladies_minority_pct))
  
  if (men_minority_pct < 5) {
    warning(sprintf("Men's %s has severe class imbalance (<5%% minority class)", target))
  }
  if (ladies_minority_pct < 5) {
    warning(sprintf("Ladies %s has severe class imbalance (<5%% minority class)", target))
  }
}

# Sample TopThree values
cat("First 20 ladies Place and TopThree values:\n")
sample_topthree <- df_place_ladies %>% 
  dplyr::select(Skier, Season, Place, TopThree) %>% 
  head(20)
print(sample_topthree)
```

**Purpose**: Provides comprehensive validation of categorical outcome creation and identifies potential modeling challenges.

**Validation Framework**:
- **Cross-Tabulation Analysis**: Validates that categorical outcomes align correctly with place rankings
- **Factor Level Verification**: Ensures all categorical outcomes have expected binary levels (0, 1)
- **Class Balance Assessment**: Identifies class imbalance that could affect odds modeling quality
- **Sample Verification**: Provides concrete examples to validate categorical outcome logic

**Class Imbalance Monitoring**:
- **Severe Imbalance Detection**: Warns when minority class <5% (could cause modeling issues)
- **Cross-Gender Comparison**: Compares class balance between men's and women's alpine skiing
- **Performance Threshold Analysis**: Shows how class balance varies across different performance thresholds

#### 6. Prediction Data Preparation for Odds Calculation
```r
# Prepare 2025 prediction data with validation
cat("\n--- 2025 Prediction Data Preparation ---\n")

# Validate prediction data exists
if (!exists("men_pred_data") || is.null(men_pred_data)) {
  warning("Men's 2026 prediction data not available from previous section")
  men_pred_data <- data.frame()
}
if (!exists("ladies_pred_data") || is.null(ladies_pred_data)) {
  warning("Ladies 2026 prediction data not available from previous section") 
  ladies_pred_data <- data.frame()
}

# Men's prediction data preparation
pred_data_men <- NULL
if (nrow(men_pred_data) > 0) {
  tryCatch({
    # Define expected columns for prediction data (alpine-specific)
    expected_pred_cols <- c("Skier", "Nation", "Pelo", "Downhill_Pelo", "Super G_Pelo", 
                           "Giant Slalom_Pelo", "Slalom_Pelo", "Combined_Pelo", 
                           "Tech_Pelo", "Speed_Pelo", "Pct_of_Max_Points")
    
    available_pred_cols <- intersect(expected_pred_cols, names(men_pred_data))
    missing_pred_cols <- setdiff(expected_pred_cols, names(men_pred_data))
    
    cat(sprintf("Men's prediction columns: %d available, %d missing\n", 
                length(available_pred_cols), length(missing_pred_cols)))
    
    if (length(missing_pred_cols) > 0) {
      cat("Missing men's prediction columns:", paste(missing_pred_cols, collapse = ", "), "\n")
    }
    
    if (length(available_pred_cols) >= 4) {  # Need at least basic info
      pred_data_men <- men_pred_data[available_pred_cols]
      
      # Rename to match training data feature names (alpine-specific)
      rename_map <- c("Prev_Pelo" = "Pelo", "Prev_Downhill" = "Downhill_Pelo", 
                     "Prev_Super_G" = "Super G_Pelo", "Prev_Giant_Slalom" = "Giant Slalom_Pelo",
                     "Prev_Slalom" = "Slalom_Pelo", "Prev_Combined" = "Combined_Pelo", 
                     "Prev_Tech" = "Tech_Pelo", "Prev_Speed" = "Speed_Pelo", 
                     "Prev_Pct_of_Max_Points" = "Pct_of_Max_Points", "Nation" = "Nation")
      
      for (old_name in names(rename_map)) {
        if (rename_map[old_name] %in% names(pred_data_men)) {
          names(pred_data_men)[names(pred_data_men) == rename_map[old_name]] <- old_name
        }
      }
      
      # Handle column names with spaces by converting to underscores
      if ("Super G_Pelo" %in% names(pred_data_men)) {
        names(pred_data_men)[names(pred_data_men) == "Super G_Pelo"] <- "Prev_Super_G"
      }
      if ("Giant Slalom_Pelo" %in% names(pred_data_men)) {
        names(pred_data_men)[names(pred_data_men) == "Giant Slalom_Pelo"] <- "Prev_Giant_Slalom"
      }
      
      cat(sprintf("✓ Men's prediction data prepared: %d rows, %d columns\n", 
                  nrow(pred_data_men), ncol(pred_data_men)))
    } else {
      warning("Insufficient columns for men's prediction data preparation")
      pred_data_men <- data.frame()
    }
    
  }, error = function(e) {
    cat("Error preparing men's prediction data:", e$message, "\n")
    pred_data_men <- data.frame()
  })
} else {
  cat("No men's prediction data available\n")
  pred_data_men <- data.frame()
}
```

**Purpose**: Prepares 2026 prediction data for odds calculation by aligning feature names and validating data availability.

**Prediction Data Processing**:
- **Alpine-Specific Column Mapping**: Handles all alpine disciplines (Downhill, Super G, Giant Slalom, Slalom, Combined)
- **Feature Name Alignment**: Converts prediction data column names to match training data format
- **Space Handling**: Properly manages alpine discipline names containing spaces
- **Minimum Data Requirements**: Ensures at least 4 columns available for meaningful odds calculation

**Data Validation**:
- **Column Availability Assessment**: Reports available vs missing prediction columns
- **Graceful Degradation**: Continues processing with available columns when some are missing
- **Error Handling**: Robust error handling ensures prediction data preparation succeeds or fails gracefully

### Alpine Odds-Specific Design Considerations

#### Performance Threshold Framework
Alpine skiing odds framework uses sport-specific performance thresholds:
- **Championship Level**: Win category captures seasonal overall victory
- **Elite Consistency**: TopThree represents podium-level alpine performance
- **Competitive Tiers**: Top5, Top10, Top30 provide graduated performance levels
- **Points System Alignment**: Top30 threshold aligns with alpine World Cup points eligibility

#### Season-Based Ranking Context
Ranking system accounts for alpine skiing's competitive structure:
- **Seasonal Context**: Rankings calculated within seasons to account for varying competitive fields
- **Performance Standardization**: Uses percentage of maximum points for cross-season comparability
- **Tie-Breaking Consistency**: Standardized tie-breaking ensures reproducible rankings

#### Alpine-Specific Data Requirements
Odds framework handles alpine skiing's multi-discipline structure:
- **Discipline Coverage**: Accommodates all five alpine disciplines plus aggregate categories
- **ELO Integration**: Incorporates discipline-specific and overall ELO ratings
- **Feature Flexibility**: Handles missing disciplines gracefully while maintaining prediction capability

### Error Handling and Quality Assurance
- **Comprehensive Data Validation**: Validates training and prediction data availability and quality
- **Ranking System Verification**: Extensive validation of season-based ranking calculations
- **Categorical Outcome Validation**: Cross-tabulation and factor level verification
- **Class Balance Monitoring**: Identifies potential modeling challenges from class imbalance
- **Prediction Data Alignment**: Ensures feature name consistency between training and prediction data

This alpine odds setup section establishes a robust framework for odds calculation that respects alpine skiing's competitive structure while providing comprehensive validation and error handling to ensure reliable odds modeling across multiple performance thresholds.

### Implementation Details

#### 1. Core Processing Function: `process_alpine_chrono_data()`
The section centers around a robust processing function tailored for alpine skiing data:

```r
process_alpine_chrono_data <- function(chrono_df, data_name = "Unknown") {
  
  cat(sprintf("\n--- Processing %s Alpine Data ---\n", data_name))
  
  # Input validation
  if (nrow(chrono_df) == 0) {
    stop(sprintf("%s alpine dataset is empty", data_name))
  }
  
  # Check for required columns before processing
  required_cols <- c("Event", "Nation", "Place", "Distance", "Date", "Race", "ID", "Season")
  missing_cols <- setdiff(required_cols, names(chrono_df))
  if (length(missing_cols) > 0) {
    stop(sprintf("Missing required columns in %s alpine data: %s", data_name, paste(missing_cols, collapse = ", ")))
  }
  
  original_rows <- nrow(chrono_df)
  cat(sprintf("Input: %d rows\n", original_rows))
}
```

**Purpose**: Provides a specialized framework for processing alpine skiing data that handles the sport's unique competitive structure and points system.

**Key Features**:
- **Parameterized Processing**: Accepts data name for detailed logging
- **Input Validation**: Ensures data integrity before processing
- **Column Validation**: Verifies all required fields are present
- **Progress Tracking**: Reports processing steps with row counts

#### 2. Alpine Points Assignment and Validation
```r
# Add Alpine World Cup points
cat("Adding Alpine World Cup points...\n")
df <- chrono_df %>%
  mutate(Points = map_int(Place, ~ get_alpine_points(.x, alpine_points)))

# Validate points assignment
points_na <- sum(is.na(df$Points))
points_negative <- sum(df$Points < 0, na.rm = TRUE)

if (points_na > 0) {
  warning(sprintf("%s: %d rows have NA points", data_name, points_na))
}
if (points_negative > 0) {
  warning(sprintf("%s: %d rows have negative points", data_name, points_negative))
}

cat(sprintf("Alpine points range: %d - %d\n", min(df$Points, na.rm = TRUE), max(df$Points, na.rm = TRUE)))
```

**Purpose**: Applies the Alpine World Cup points system to race results and validates the assignment process.

**Points Assignment Logic**:
- Uses `get_alpine_points()` function to safely assign points based on placement
- Awards 100 points for 1st place down to 1 point for 30th place
- Returns 0 points for placements outside top 30
- Handles edge cases (NA, negative, or invalid placements)

**Validation Features**:
- Checks for NA points assignments
- Identifies negative points (should not occur)
- Reports points range for verification

#### 3. Event Filtering and Competition Focus
```r
# Count events before filtering
event_counts_before <- table(df$Event)
cat("Events before filtering:\n")
print(event_counts_before)

# Filter for relevant alpine events (only World Cup and Offseason)
cat("Filtering for relevant alpine events (World Cup, Offseason)...\n")
relevant_events <- c("World Cup", "Offseason")

df <- df %>%
  filter(Event %in% relevant_events) %>%
  arrange(Date, Race, Place) %>%
  group_by(ID, Season) %>%
  mutate(
    Cumulative_Points = cumsum(Points),
    Races_in_Season = n()
  ) %>%
  ungroup()

filtered_rows <- nrow(df)
cat(sprintf("After alpine event filtering: %d rows (removed %d rows)\n", filtered_rows, original_rows - filtered_rows))

# Count events after filtering
event_counts_after <- table(df$Event)
cat("Alpine events after filtering:\n")
print(event_counts_after)
```

**Purpose**: Focuses analysis on the most relevant competitions for performance prediction while tracking filtering impact.

**Event Filtering Logic**:
- **World Cup**: Primary elite alpine racing circuit
- **Offseason**: Summer and training competitions
- **Exclusions**: Removes lower-level competitions that are less predictive

**Feature Engineering**:
- **Cumulative_Points**: Running total of points earned within each season
- **Races_in_Season**: Count of races participated in each season
- **Date Ordering**: Ensures chronological processing for cumulative calculations

#### 4. Cumulative Points Calculation Validation
```r
# Validate cumulative points calculation
invalid_cumulative <- df %>%
  group_by(ID, Season) %>%
  mutate(expected_cumulative = cumsum(Points)) %>%
  ungroup() %>%
  filter(Cumulative_Points != expected_cumulative) %>%
  nrow()

if (invalid_cumulative > 0) {
  warning(sprintf("%s: %d rows have incorrect cumulative points", data_name, invalid_cumulative))
} else {
  cat("✓ Cumulative points calculation validated\n")
}
```

**Purpose**: Validates that cumulative points are calculated correctly by comparing against expected values.

**Validation Method**:
- Recalculates cumulative points independently
- Compares against stored cumulative values
- Identifies any discrepancies in the calculation
- Ensures data integrity for downstream analysis

#### 5. Alpine Discipline Analysis
```r
# Alpine doesn't have team events like cross-country, but check for any unusual distances
cat("Checking alpine disciplines...\n")
discipline_counts <- table(df$Distance)
cat("Alpine disciplines:\n")
print(discipline_counts)
```

**Purpose**: Analyzes the distribution of alpine disciplines to ensure comprehensive coverage and identify any data anomalies.

**Alpine Discipline Context**:
- **Individual Events Only**: Unlike cross-country, alpine has no team events
- **Multiple Disciplines**: Downhill, Super G, Giant Slalom, Slalom, Combined
- **Distance Field Usage**: The Distance field contains discipline information in alpine data

#### 6. Maximum Points Calculation and Percentage Metrics
```r
# Calculate maximum possible points per season 
cat("Calculating maximum possible alpine points per season...\n")
max_points_per_season <- df %>%
  group_by(Season, Date, Race) %>%
  summarise(Max_Race_Points = max(Points), .groups = 'drop') %>%
  group_by(Season) %>%
  summarise(Max_Points = sum(Max_Race_Points), .groups = 'drop')

# Validate max points calculation
if (nrow(max_points_per_season) == 0) {
  stop(sprintf("%s: No seasons found for alpine max points calculation", data_name))
}

# Check for seasons with zero max points
zero_max_seasons <- max_points_per_season %>% filter(Max_Points == 0)
if (nrow(zero_max_seasons) > 0) {
  warning(sprintf("%s: %d alpine seasons have zero max points", data_name, nrow(zero_max_seasons)))
  print(zero_max_seasons)
}

cat(sprintf("Alpine max points range by season: %d - %d\n", 
            min(max_points_per_season$Max_Points), max(max_points_per_season$Max_Points)))
```

**Purpose**: Calculates the theoretical maximum points possible in each season to enable performance percentage calculations.

**Maximum Points Logic**:
- **Race-Level Maximum**: Finds highest points awarded in each race (typically 100 for winners)
- **Season Aggregation**: Sums maximum points across all races in each season
- **Validation**: Ensures all seasons have positive maximum points

**Performance Standardization**: Enables comparison across different seasons with varying numbers of races.

#### 7. Performance Percentage Calculation and Validation
```r
# Join max points and calculate percentage
cat("Calculating percentage of maximum alpine points...\n")
before_join <- nrow(df)

df <- df %>%
  left_join(max_points_per_season, by = "Season") %>%
  mutate(Pct_of_Max_Points = Cumulative_Points / Max_Points)

after_join <- nrow(df)
if (before_join != after_join) {
  warning(sprintf("%s: Row count changed during alpine max points join: %d -> %d", data_name, before_join, after_join))
}

# Validate percentage calculations
pct_na <- sum(is.na(df$Pct_of_Max_Points))
pct_negative <- sum(df$Pct_of_Max_Points < 0, na.rm = TRUE)
pct_over_one <- sum(df$Pct_of_Max_Points > 1, na.rm = TRUE)

if (pct_na > 0) {
  warning(sprintf("%s: %d rows have NA percentage of max alpine points", data_name, pct_na))
}
if (pct_negative > 0) {
  warning(sprintf("%s: %d rows have negative percentage of max alpine points", data_name, pct_negative))
}
if (pct_over_one > 0) {
  warning(sprintf("%s: %d rows have percentage > 100%% of max alpine points", data_name, pct_over_one))
}

cat(sprintf("Alpine percentage range: %.3f - %.3f\n", 
            min(df$Pct_of_Max_Points, na.rm = TRUE), max(df$Pct_of_Max_Points, na.rm = TRUE)))
```

**Purpose**: Creates standardized performance metrics by calculating what percentage of maximum possible points each athlete achieved.

**Percentage Calculation**:
- **Formula**: (Cumulative Points / Season Max Points)
- **Range**: 0.0 (no points) to 1.0 (won every race)
- **Standardization**: Enables comparison across different season lengths

**Validation Checks**:
- **Row Count**: Ensures join operation doesn't change data size
- **NA Values**: Identifies missing percentage calculations
- **Range**: Validates percentages are between 0 and 1
- **Logical Constraints**: Flags impossible values (negative or >100%)

#### 8. Final Validation and Summary Statistics
```r
# Final validation checks
cat("\n--- Final Alpine Validation ---\n")

# Check for required columns in output
expected_output_cols <- c("Points", "Cumulative_Points", "Races_in_Season", "Max_Points", "Pct_of_Max_Points")
missing_output_cols <- setdiff(expected_output_cols, names(df))
if (length(missing_output_cols) > 0) {
  stop(sprintf("%s: Missing expected alpine output columns: %s", data_name, paste(missing_output_cols, collapse = ", ")))
}

# Summary statistics
cat(sprintf("✓ Alpine processing complete for %s\n", data_name))
cat(sprintf("Final rows: %d (%.1f%% of original)\n", nrow(df), 100 * nrow(df) / original_rows))
cat(sprintf("Unique alpine skiers: %d\n", length(unique(df$Skier))))
cat(sprintf("Alpine seasons covered: %d (%s - %s)\n", 
            length(unique(df$Season)), min(df$Season), max(df$Season)))
cat(sprintf("Average alpine races per season per skier: %.1f\n", mean(df$Races_in_Season)))
```

**Purpose**: Provides final validation and comprehensive summary of the processed alpine data.

**Output Validation**:
- **Required Columns**: Ensures all expected columns are present
- **Data Completeness**: Reports final data size and retention rate
- **Coverage Metrics**: Summarizes unique skiers and season coverage
- **Racing Activity**: Reports average participation rates

#### 9. Cross-Dataset Processing and Validation
```r
# Process both alpine datasets with validation
cat("\n=== PROCESSING MEN'S ALPINE DATA ===\n")
tryCatch({
  M_processed <- process_alpine_chrono_data(M_chrono, "Men's")
}, error = function(e) {
  stop("Failed to process men's alpine data: ", e$message)
})

cat("\n=== PROCESSING LADIES ALPINE DATA ===\n")
tryCatch({
  L_processed <- process_alpine_chrono_data(L_chrono, "Ladies")
}, error = function(e) {
  stop("Failed to process ladies alpine data: ", e$message)
})

# Cross-validation between alpine datasets
cat("\n=== CROSS-DATASET ALPINE VALIDATION ===\n")

# Compare season ranges
men_seasons <- sort(unique(M_processed$Season))
ladies_seasons <- sort(unique(L_processed$Season))

cat("Men's alpine seasons:", paste(range(men_seasons), collapse = " - "), "(", length(men_seasons), "seasons )\n")
cat("Ladies alpine seasons:", paste(range(ladies_seasons), collapse = " - "), "(", length(ladies_seasons), "seasons )\n")

# Check for season overlap
common_seasons <- intersect(men_seasons, ladies_seasons)
cat("Common alpine seasons:", length(common_seasons), "\n")

if (length(common_seasons) == 0) {
  warning("No common seasons between men's and ladies alpine data")
}
```

**Purpose**: Applies processing to both men's and women's alpine data and validates consistency between datasets.

**Cross-Validation Features**:
- **Parallel Processing**: Applies same function to both datasets
- **Error Handling**: Isolates processing errors to specific datasets
- **Season Coverage**: Compares temporal coverage between datasets
- **Overlap Analysis**: Ensures adequate common data for comparative analysis

#### 10. Star Athlete Validation Testing
```r
# Test with star athletes to validate processing
cat("\n=== ALPINE STAR ATHLETE VALIDATION ===\n")

# Test Marco Odermatt (men)
odermatt_data <- M_processed %>% 
  filter(Skier == "Marco Odermatt") %>%
  arrange(Season, Date)

if (nrow(odermatt_data) > 0) {
  cat("✓ Marco Odermatt found in men's data\n")
  cat(sprintf("  Seasons: %s - %s\n", min(odermatt_data$Season), max(odermatt_data$Season)))
  cat(sprintf("  Total races: %d\n", nrow(odermatt_data)))
  cat(sprintf("  Career points: %d\n", sum(odermatt_data$Points)))
  
  # Show recent season performance
  recent_season <- max(odermatt_data$Season)
  recent_data <- odermatt_data %>% filter(Season == recent_season)
  cat(sprintf("  %d season: %d races, %d points, %.1f%% of max\n", 
              recent_season, nrow(recent_data), sum(recent_data$Points),
              max(recent_data$Pct_of_Max_Points) * 100))
} else {
  warning("Marco Odermatt not found in men's alpine data")
}
```

**Purpose**: Validates processing accuracy using known high-performing athletes as test cases.

**Validation Athletes**:
- **Marco Odermatt**: Top men's alpine skier for validation
- **Mikaela Shiffrin**: Top women's alpine skier for validation

**Test Metrics**:
- **Data Presence**: Confirms star athletes are found in processed data
- **Career Span**: Validates reasonable season coverage
- **Performance Metrics**: Checks points and percentage calculations
- **Recent Performance**: Validates latest season data

### Alpine-Specific Design Considerations

#### Single Points System
Alpine skiing uses one consistent points system:
- **Uniform Application**: Same points structure across all disciplines
- **Top 30 Scoring**: Only top 30 finishers receive points
- **Winner Premium**: 100 points for victory vs. 80 for second place

#### Event Hierarchy
Processing focuses on performance-relevant competitions:
- **World Cup**: Primary elite circuit (highest priority)
- **Offseason**: Training and summer competitions (secondary priority)
- **Lower Levels**: Excluded to focus on predictive competitions

#### Performance Standardization
Percentage calculations account for alpine skiing characteristics:
- **Variable Schedules**: Athletes compete in different numbers of races
- **Discipline Specialization**: Some athletes focus on specific disciplines
- **Season Length Variation**: Different seasons may have different race calendars

### Error Handling and Quality Assurance
- **Input Validation**: Comprehensive checks for data structure and completeness
- **Processing Validation**: Validates each step of feature engineering and calculation
- **Cross-Dataset Consistency**: Ensures consistent processing across men's and women's data
- **Star Athlete Testing**: Uses known high performers to validate processing accuracy
- **Comprehensive Logging**: Detailed progress reporting and diagnostic output

This alpine data processing section provides a robust foundation for subsequent analysis, creating standardized performance metrics while preserving the unique characteristics of alpine skiing competition and its points system.

## Section: {r elo-prep} - Alpine ELO Data Preparation & Feature Engineering

### Purpose
This section prepares alpine ELO (rating system) data for machine learning models by filtering offseason data, creating lagged features for previous season performance, and implementing comprehensive missing value treatment specific to alpine skiing's multi-discipline structure.

### Implementation Details

#### 1. Missing Value Helper Function
```r
# Helper function for quartile replacement (handles NAs by replacing with 1st quartile within season)
replace_na_with_quartile <- function(x, var_name) {
  if (all(is.na(x))) {
    warning(sprintf("All values NA for %s in this season - using global mean", var_name))
    return(rep(mean(x, na.rm = TRUE), length(x)))
  }
  
  q1 <- quantile(x, 0.25, na.rm = TRUE)
  if (is.na(q1)) {
    warning(sprintf("Cannot calculate quartile for %s - using mean", var_name))
    q1 <- mean(x, na.rm = TRUE)
  }
  
  return(replace(x, is.na(x), q1))
}
```

**Purpose**: Provides robust missing value imputation using first quartile values within each season, with fallback strategies for edge cases.

**Imputation Strategy**:
- **Primary Method**: Uses first quartile (25th percentile) within season
- **Fallback 1**: If all values are NA in season, uses global mean
- **Fallback 2**: If quartile calculation fails, uses season mean
- **Conservative Approach**: First quartile provides conservative estimates for missing ELO ratings

#### 2. Core ELO Preparation Function
```r
prepare_alpine_elo_data <- function(processed_df, data_name = "Unknown") {
  
  cat(sprintf("\n--- Preparing %s Alpine ELO Data ---\n", data_name))
  
  # Input validation
  if (nrow(processed_df) == 0) {
    stop(sprintf("%s alpine dataset is empty", data_name))
  }
  
  original_rows <- nrow(processed_df)
  cat(sprintf("Input: %d rows\n", original_rows))
  
  # Check for offseason data
  offseason_count <- sum(processed_df$Event == "Offseason", na.rm = TRUE)
  cat(sprintf("Offseason events available: %d\n", offseason_count))
  
  if (offseason_count == 0) {
    stop(sprintf("%s: No offseason data found for alpine ELO preparation", data_name))
  }
}
```

**Purpose**: Establishes the framework for alpine ELO data preparation with comprehensive validation.

**Key Validation Steps**:
- **Empty Dataset Check**: Ensures data is available for processing
- **Offseason Data Requirement**: Validates presence of offseason data (essential for ELO preparation)
- **Progress Tracking**: Reports input data size and availability

#### 3. Alpine ELO Column Validation
```r
# Check for required alpine ELO columns before processing
required_elo_cols <- c("Pelo", "Downhill_Pelo", "Super G_Pelo", "Giant Slalom_Pelo", 
                       "Slalom_Pelo", "Combined_Pelo", "Tech_Pelo", "Speed_Pelo")

available_elo_cols <- intersect(required_elo_cols, names(processed_df))
missing_elo_cols <- setdiff(required_elo_cols, names(processed_df))

cat(sprintf("Available alpine ELO columns: %d/%d\n", length(available_elo_cols), length(required_elo_cols)))
if (length(missing_elo_cols) > 0) {
  cat("Missing alpine ELO columns:", paste(missing_elo_cols, collapse = ", "), "\n")
  warning(sprintf("%s: Missing some alpine ELO columns - proceeding with available columns", data_name))
}
```

**Purpose**: Validates availability of alpine-specific ELO rating columns and handles graceful degradation if some are missing.

**Alpine ELO Structure**:
- **Pelo**: Overall alpine ELO rating
- **Downhill_Pelo**: Downhill-specific ELO rating
- **Super G_Pelo**: Super G-specific ELO rating
- **Giant Slalom_Pelo**: Giant Slalom-specific ELO rating
- **Slalom_Pelo**: Slalom-specific ELO rating
- **Combined_Pelo**: Combined event ELO rating
- **Tech_Pelo**: Technical disciplines (Slalom, Giant Slalom) aggregate ELO
- **Speed_Pelo**: Speed disciplines (Downhill, Super G) aggregate ELO

**Flexible Processing**: Continues with available columns if some ELO ratings are missing.

#### 4. Offseason Data Filtering and Lag Feature Creation
```r
# Filter for offseason data and create previous season ELO values
cat("Filtering for offseason data and creating lag features...\n")

elo_df <- processed_df %>%
  filter(Event == "Offseason") %>%
  arrange(ID, Season)

filtered_rows <- nrow(elo_df)
cat(sprintf("After offseason filter: %d rows (%.1f%% of input)\n", 
            filtered_rows, 100 * filtered_rows / original_rows))

if (filtered_rows == 0) {
  stop(sprintf("%s: No rows remaining after offseason filtering", data_name))
}

# Create lag features for alpine disciplines with validation
cat("Creating alpine discipline lag features...\n")

elo_df <- elo_df %>%
  group_by(ID) %>%
  mutate(
    Prev_Pelo = if("Pelo" %in% names(.)) lag(Pelo) else NA_real_,
    Prev_Downhill = if("Downhill_Pelo" %in% names(.)) lag(Downhill_Pelo) else NA_real_,
    Prev_Super_G = if("Super G_Pelo" %in% names(.)) lag(`Super G_Pelo`) else NA_real_,
    Prev_Giant_Slalom = if("Giant Slalom_Pelo" %in% names(.)) lag(`Giant Slalom_Pelo`) else NA_real_,
    Prev_Slalom = if("Slalom_Pelo" %in% names(.)) lag(Slalom_Pelo) else NA_real_,
    Prev_Combined = if("Combined_Pelo" %in% names(.)) lag(Combined_Pelo) else NA_real_,
    Prev_Tech = if("Tech_Pelo" %in% names(.)) lag(Tech_Pelo) else NA_real_,
    Prev_Speed = if("Speed_Pelo" %in% names(.)) lag(Speed_Pelo) else NA_real_,
    Prev_Pct_of_Max_Points = lag(Pct_of_Max_Points)
  ) %>%
  ungroup()
```

**Purpose**: Extracts offseason data and creates lagged features representing previous season performance across all alpine disciplines.

**Offseason Focus**: 
- **End-of-Season Snapshot**: Offseason data represents final ELO ratings after season completion
- **Predictive Features**: Previous season ELO ratings serve as predictors for next season performance
- **Clean Temporal Ordering**: Arranges by athlete ID and season for proper lag calculation

**Lag Feature Engineering**:
- **Previous Overall Rating**: `Prev_Pelo` for general alpine ability
- **Discipline-Specific Ratings**: Previous ELO for each alpine discipline
- **Aggregate Category Ratings**: Previous Technical and Speed ELO ratings
- **Performance Percentage**: Previous season's percentage of maximum points achieved

#### 5. Season Filtering and Validation
```r
# Apply season filter
cat("Applying season filter (> 2015)...\n")
before_season_filter <- nrow(elo_df)

elo_df <- elo_df %>%
  filter(Season > 2015)

after_season_filter <- nrow(elo_df)
cat(sprintf("After season filter: %d rows (removed %d rows from ≤2015)\n", 
            after_season_filter, before_season_filter - after_season_filter))

if (after_season_filter == 0) {
  stop(sprintf("%s: No rows remaining after alpine season filtering (>2015)", data_name))
}

# Validate season range
season_range <- range(elo_df$Season, na.rm = TRUE)
cat(sprintf("Final alpine season range: %.0f - %.0f\n", season_range[1], season_range[2]))
```

**Purpose**: Focuses analysis on modern alpine skiing era (post-2015) to ensure ELO ratings reflect current competitive dynamics.

**Season Filter Rationale**:
- **Modern Era Focus**: 2016+ represents current alpine skiing competitive structure
- **ELO System Stability**: Ensures ELO ratings have stabilized and are reliable
- **Equipment and Rule Consistency**: Reduces impact of equipment changes and rule modifications
- **Data Quality**: More recent data has better quality and completeness

#### 6. Comprehensive Missing Value Treatment
```r
# Handle missing values by replacing with quartiles within each season
cat("\n--- Alpine ELO Missing Value Treatment ---\n")

# Count NAs before treatment
if (length(created_lag_features) > 0) {
  available_lag_features <- intersect(created_lag_features, names(elo_df))
  if (length(available_lag_features) > 0) {
    na_summary_before <- elo_df[available_lag_features] %>%
      summarise_all(~ sum(is.na(.))) %>%
      gather(variable, na_count) %>%
      filter(na_count > 0)
  }
}

if (nrow(na_summary_before) > 0) {
  cat("Alpine ELO NAs before treatment:\n")
  print(na_summary_before)
} else {
  cat("No NAs found in alpine lag features\n")
}

# Apply quartile replacement by season for alpine disciplines
cat("Applying quartile replacement by season for alpine disciplines...\n")

elo_df <- elo_df %>%
  group_by(Season) %>%
  mutate(
    Prev_Downhill = if("Prev_Downhill" %in% names(.)) replace_na_with_quartile(Prev_Downhill, "Prev_Downhill") else Prev_Downhill,
    Prev_Super_G = if("Prev_Super_G" %in% names(.)) replace_na_with_quartile(Prev_Super_G, "Prev_Super_G") else Prev_Super_G,
    Prev_Giant_Slalom = if("Prev_Giant_Slalom" %in% names(.)) replace_na_with_quartile(Prev_Giant_Slalom, "Prev_Giant_Slalom") else Prev_Giant_Slalom,
    Prev_Slalom = if("Prev_Slalom" %in% names(.)) replace_na_with_quartile(Prev_Slalom, "Prev_Slalom") else Prev_Slalom,
    Prev_Combined = if("Prev_Combined" %in% names(.)) replace_na_with_quartile(Prev_Combined, "Prev_Combined") else Prev_Combined,
    Prev_Tech = if("Prev_Tech" %in% names(.)) replace_na_with_quartile(Prev_Tech, "Prev_Tech") else Prev_Tech,
    Prev_Speed = if("Prev_Speed" %in% names(.)) replace_na_with_quartile(Prev_Speed, "Prev_Speed") else Prev_Speed,
    Prev_Pelo = if("Prev_Pelo" %in% names(.)) replace_na_with_quartile(Prev_Pelo, "Prev_Pelo") else Prev_Pelo,
    Prev_Pct_of_Max_Points = replace(Prev_Pct_of_Max_Points, is.na(Prev_Pct_of_Max_Points), 0)
  ) %>%
  ungroup()
```

**Purpose**: Implements sophisticated missing value imputation that respects alpine skiing's competitive context and seasonal variations.

**Season-Based Imputation Strategy**:
- **Within-Season Context**: Replaces missing ELO values using quartiles within the same season
- **Conservative Estimates**: First quartile provides conservative performance estimates
- **Discipline-Specific Treatment**: Each alpine discipline gets independent imputation
- **Performance Points Special Case**: Missing performance percentages set to 0 (indicating no previous season success)

**Quality Assurance**:
- **Before/After Comparison**: Tracks missing value counts before and after treatment
- **Validation Reporting**: Reports remaining missing values if any exist
- **Error Handling**: Warns if imputation is incomplete

#### 7. Final Data Quality Validation
```r
# Final validation checks
cat("\n--- Final Alpine ELO Validation ---\n")

# Check for infinite values
numeric_cols <- select_if(elo_df, is.numeric) %>% names()
if (length(numeric_cols) > 0) {
  inf_check <- elo_df[numeric_cols] %>%
    summarise_all(~ sum(!is.finite(.))) %>%
    gather(variable, inf_count) %>%
    filter(inf_count > 0)
}

if (nrow(inf_check) > 0) {
  cat("Infinite values found in alpine ELO data:\n")
  print(inf_check)
  warning(sprintf("%s: Contains infinite values", data_name))
} else {
  cat("✓ No infinite values detected in alpine ELO data\n")
}

# Validate key relationships for alpine
if ("Age" %in% names(elo_df)) {
  age_issues <- elo_df %>%
    filter(Age < 15 | Age > 50) %>%
    nrow()
  
  if (age_issues > 0) {
    warning(sprintf("%s: %d rows with unusual ages (<15 or >50)", data_name, age_issues))
  }
  
  cat(sprintf("Alpine skier age range: %.0f - %.0f\n", min(elo_df$Age, na.rm = TRUE), max(elo_df$Age, na.rm = TRUE)))
}
```

**Purpose**: Performs comprehensive final validation to ensure data quality and logical consistency.

**Validation Checks**:
- **Infinite Value Detection**: Identifies any infinite or NaN values that could break models
- **Age Range Validation**: Ensures athlete ages are within reasonable bounds (15-50 years)
- **Finite Value Verification**: Confirms all numeric values are finite and usable

**Quality Standards**:
- **Model Readiness**: Ensures data is ready for machine learning algorithms
- **Logical Consistency**: Validates that data relationships make sense
- **Error Prevention**: Catches data quality issues before they affect downstream analysis

#### 8. Cross-Dataset Processing and Analysis
```r
# Prepare alpine ELO data for both men and ladies with comprehensive validation
cat("\n=== PREPARING MEN'S ALPINE ELO DATA ===\n")
tryCatch({
  M_elo <- prepare_alpine_elo_data(M_processed, "Men's")
}, error = function(e) {
  stop("Failed to prepare men's alpine ELO data: ", e$message)
})

cat("\n=== PREPARING LADIES ALPINE ELO DATA ===\n")
tryCatch({
  L_elo <- prepare_alpine_elo_data(L_processed, "Ladies")
}, error = function(e) {
  stop("Failed to prepare ladies alpine ELO data: ", e$message)
})

# Cross-validation between alpine ELO datasets
cat("\n=== CROSS-DATASET ALPINE ELO VALIDATION ===\n")

# Compare season ranges
men_elo_seasons <- sort(unique(M_elo$Season))
ladies_elo_seasons <- sort(unique(L_elo$Season))

cat("Men's alpine ELO seasons:", paste(range(men_elo_seasons), collapse = " - "), "(", length(men_elo_seasons), "seasons )\n")
cat("Ladies alpine ELO seasons:", paste(range(ladies_elo_seasons), collapse = " - "), "(", length(ladies_elo_seasons), "seasons )\n")

# Check for season overlap
common_elo_seasons <- intersect(men_elo_seasons, ladies_elo_seasons)
cat("Common alpine ELO seasons:", length(common_elo_seasons), "\n")

if (length(common_elo_seasons) == 0) {
  warning("No common seasons between men's and ladies alpine ELO data")
}
```

**Purpose**: Applies ELO preparation to both men's and women's data with comprehensive cross-validation.

**Processing Features**:
- **Parallel Processing**: Applies same preparation function to both datasets
- **Error Isolation**: Isolates processing errors to specific datasets
- **Season Coverage Comparison**: Validates temporal coverage between men's and women's data
- **Overlap Analysis**: Ensures adequate common seasons for comparative modeling

#### 9. Alpine ELO Distribution Analysis
```r
# Validate alpine ELO distributions
cat("\n--- Alpine ELO Distribution Analysis ---\n")

# Check ELO ranges for men
if ("Prev_Pelo" %in% names(M_elo)) {
  men_pelo_range <- range(M_elo$Prev_Pelo, na.rm = TRUE)
  cat(sprintf("Men's Prev_Pelo range: %.0f - %.0f\n", men_pelo_range[1], men_pelo_range[2]))
}

if ("Prev_Tech" %in% names(M_elo)) {
  men_tech_range <- range(M_elo$Prev_Tech, na.rm = TRUE)
  cat(sprintf("Men's Prev_Tech range: %.0f - %.0f\n", men_tech_range[1], men_tech_range[2]))
}

if ("Prev_Speed" %in% names(M_elo)) {
  men_speed_range <- range(M_elo$Prev_Speed, na.rm = TRUE)
  cat(sprintf("Men's Prev_Speed range: %.0f - %.0f\n", men_speed_range[1], men_speed_range[2]))
}
```

**Purpose**: Analyzes ELO rating distributions to validate data quality and identify potential issues.

**Distribution Analysis**:
- **Overall Alpine ELO**: General alpine skiing ability ratings
- **Technical Disciplines**: Slalom and Giant Slalom combined ratings
- **Speed Disciplines**: Downhill and Super G combined ratings
- **Range Validation**: Ensures ELO ranges are reasonable and consistent

### Alpine ELO-Specific Design Considerations

#### Multi-Discipline ELO Structure
Alpine skiing's unique characteristic is having separate ELO ratings for each discipline:
- **Individual Discipline Ratings**: Separate ELO for Downhill, Super G, Giant Slalom, Slalom, Combined
- **Aggregate Category Ratings**: Technical (Slalom + Giant Slalom) and Speed (Downhill + Super G)
- **Overall Alpine Rating**: General alpine skiing ability across all disciplines

#### Offseason Data Focus
ELO preparation specifically targets offseason data:
- **End-of-Season Ratings**: Represents final ELO after all season races completed
- **Stable Performance Indicators**: ELO ratings have stabilized by offseason
- **Predictive Value**: End-of-season ratings are most predictive of next season performance

#### Conservative Missing Value Treatment
The quartile-based imputation strategy:
- **Conservative Estimates**: First quartile provides conservative performance expectations
- **Season-Aware**: Imputation respects seasonal competitive context
- **Discipline-Specific**: Each alpine discipline gets independent treatment
- **Graceful Degradation**: Handles edge cases with appropriate fallback strategies

### Error Handling and Quality Assurance
- **Input Validation**: Comprehensive checks for data availability and structure
- **ELO Column Validation**: Flexible handling of missing discipline-specific ELO columns
- **Missing Value Monitoring**: Detailed tracking of missing value treatment effectiveness
- **Cross-Dataset Consistency**: Ensures consistent processing across men's and women's data
- **Distribution Validation**: Analyzes ELO distributions for quality assurance

This alpine ELO preparation section creates a robust foundation for machine learning models by providing clean, validated, and properly engineered features that respect alpine skiing's multi-discipline competitive structure and seasonal dynamics.

## Section: {r comprehensive-feature-selection} - Alpine Feature Selection & Model Optimization

### Purpose
This section implements comprehensive feature selection for alpine skiing season prediction using multiple statistical and machine learning methods. It identifies the most predictive alpine-specific features across all disciplines and creates robust consensus-based feature sets for both men's and women's modeling.

### Implementation Details

#### 1. Training Data Preparation and Validation
```r
cat("=== COMPREHENSIVE ALPINE FEATURE SELECTION & VALIDATION ===\n")

# Input validation for alpine ELO datasets
if (nrow(M_elo) == 0) {
  stop("Men's alpine ELO dataset is empty")
}
if (nrow(L_elo) == 0) {
  stop("Ladies alpine ELO dataset is empty")
}

cat(sprintf("Input alpine datasets: Men %d rows, Ladies %d rows\n", nrow(M_elo), nrow(L_elo)))

# Prepare training data - include more historical seasons to capture early breakthroughs
# Use data from 2016+ to include breakthrough seasons in alpine
cat("Filtering alpine training data (2016-2025, non-NA Pct_of_Max_Points)...\n")

# Check available seasons before filtering
men_seasons_available <- sort(unique(M_elo$Season))
ladies_seasons_available <- sort(unique(L_elo$Season))

cat(sprintf("Men's alpine available seasons: %s\n", paste(range(men_seasons_available), collapse = " - ")))
cat(sprintf("Ladies alpine available seasons: %s\n", paste(range(ladies_seasons_available), collapse = " - ")))

# Apply training filters with validation
train_men <- M_elo %>% 
  filter(Season <= 2025, Season >= 2016) %>% 
  filter(!is.na(Pct_of_Max_Points))

train_ladies <- L_elo %>% 
  filter(Season <= 2025, Season >= 2016) %>% 
  filter(!is.na(Pct_of_Max_Points))
```

**Purpose**: Establishes comprehensive training datasets with validated temporal coverage for alpine skiing feature selection.

**Training Data Strategy**:
- **Historical Coverage**: Uses 2016-2025 data to capture full range of alpine performance patterns
- **Target Variable Validation**: Ensures non-missing percentage of maximum points for supervised learning
- **Season Range Validation**: Confirms adequate temporal coverage for robust feature selection
- **Breakthrough Inclusion**: 2016+ timeframe captures early career breakthroughs in alpine skiing

**Quality Assurance**:
- **Empty Dataset Protection**: Prevents feature selection with insufficient data
- **Season Coverage Reporting**: Validates temporal span of training data
- **Model Robustness Check**: Warns if fewer than 3 seasons available

#### 2. Alpine Feature Definition and Availability Validation
```r
# Define and validate potential alpine features
cat("\n--- Alpine Feature Validation ---\n")

all_features <- c("Prev_Pelo", "Prev_Downhill", "Prev_Super_G", "Prev_Giant_Slalom", 
                  "Prev_Slalom", "Prev_Combined", "Prev_Tech", "Prev_Speed", 
                  "Prev_Pct_of_Max_Points", "Age")

# Check feature availability in alpine training datasets
men_available_features <- intersect(all_features, names(train_men))
ladies_available_features <- intersect(all_features, names(train_ladies))

cat(sprintf("Men's available alpine features: %d/%d\n", length(men_available_features), length(all_features)))
cat(sprintf("Ladies available alpine features: %d/%d\n", length(ladies_available_features), length(all_features)))

# Report missing features
men_missing_features <- setdiff(all_features, men_available_features)
ladies_missing_features <- setdiff(all_features, ladies_available_features)

if (length(men_missing_features) > 0) {
  cat("Men's missing alpine features:", paste(men_missing_features, collapse = ", "), "\n")
  warning("Some alpine features missing from men's training data")
}
if (length(ladies_missing_features) > 0) {
  cat("Ladies missing alpine features:", paste(ladies_missing_features, collapse = ", "), "\n")
  warning("Some alpine features missing from ladies training data")
}
```

**Purpose**: Validates availability of alpine-specific predictive features and handles graceful degradation for missing features.

**Alpine Feature Set**:
- **Overall Alpine Performance**: `Prev_Pelo` (previous season overall ELO)
- **Individual Discipline ELOs**: `Prev_Downhill`, `Prev_Super_G`, `Prev_Giant_Slalom`, `Prev_Slalom`, `Prev_Combined`
- **Discipline Category ELOs**: `Prev_Tech` (technical disciplines), `Prev_Speed` (speed disciplines)
- **Performance History**: `Prev_Pct_of_Max_Points` (previous season success rate)
- **Athlete Demographics**: `Age` (current age for experience modeling)

**Flexible Processing**:
- **Graceful Degradation**: Continues with available features if some are missing
- **Minimum Threshold**: Requires at least 3 features for meaningful feature selection
- **Cross-Gender Validation**: Ensures consistent feature availability across men's and women's data

#### 3. Data Quality Validation for Feature Selection
```r
# Validate alpine feature data quality
cat("\n--- Alpine Feature Data Quality Checks ---\n")

# Check for missing values in alpine features
men_feature_na_counts <- sapply(train_men[all_features_men], function(x) sum(is.na(x)))
ladies_feature_na_counts <- sapply(train_ladies[all_features_ladies], function(x) sum(is.na(x)))

if (any(men_feature_na_counts > 0)) {
  cat("Men's alpine features with NAs:\n")
  print(men_feature_na_counts[men_feature_na_counts > 0])
  warning("Men's alpine training data contains missing values in features")
}

# Check for infinite values
men_feature_inf_counts <- sapply(train_men[all_features_men], function(x) sum(!is.finite(x)))
ladies_feature_inf_counts <- sapply(train_ladies[all_features_ladies], function(x) sum(!is.finite(x)))

# Check target variable quality
men_target_na <- sum(is.na(train_men$Pct_of_Max_Points))
ladies_target_na <- sum(is.na(train_ladies$Pct_of_Max_Points))

cat(sprintf("Alpine target variable ranges: Men %.3f-%.3f, Ladies %.3f-%.3f\n",
            min(train_men$Pct_of_Max_Points, na.rm = TRUE), max(train_men$Pct_of_Max_Points, na.rm = TRUE),
            min(train_ladies$Pct_of_Max_Points, na.rm = TRUE), max(train_ladies$Pct_of_Max_Points, na.rm = TRUE)))
```

**Purpose**: Ensures data quality standards necessary for reliable feature selection across alpine skiing datasets.

**Quality Validation Checks**:
- **Missing Value Detection**: Identifies features with incomplete data that could bias selection
- **Infinite Value Detection**: Finds numerical issues that could break feature selection algorithms
- **Target Variable Validation**: Ensures target variable (percentage of maximum points) has valid range
- **Cross-Dataset Consistency**: Validates data quality across men's and women's datasets

#### 4. Multi-Method Feature Selection Framework

##### 4a. Correlation Analysis
```r
# 1. CORRELATION ANALYSIS with validation
cat("1. ALPINE CORRELATION ANALYSIS:\n")
tryCatch({
  if (length(all_features_men) < 2) {
    cat("Insufficient alpine features for correlation analysis\n")
    cor_matrix_men <- NULL
    high_cor_men <- data.frame()
  } else {
    cor_matrix_men <- cor(train_men[all_features_men], use = "complete.obs")
    
    # Validate correlation matrix
    if (any(is.na(cor_matrix_men))) {
      warning("Alpine correlation matrix contains NA values")
    }
    
    high_cor_men <- which(abs(cor_matrix_men) > 0.7 & upper.tri(cor_matrix_men), arr.ind = TRUE)
    if(nrow(high_cor_men) > 0) {
      cat("High alpine correlations (|r| > 0.7):\n")
      for(i in 1:nrow(high_cor_men)) {
        row_name <- rownames(cor_matrix_men)[high_cor_men[i,1]]
        col_name <- colnames(cor_matrix_men)[high_cor_men[i,2]]
        cor_val <- cor_matrix_men[high_cor_men[i,1], high_cor_men[i,2]]
        cat(sprintf("  %s - %s: %.3f\n", row_name, col_name, cor_val))
      }
    } else {
      cat("✓ No high alpine correlations found\n")
    }
  }
}, error = function(e) {
  cat("Error in alpine correlation analysis:", e$message, "\n")
  cor_matrix_men <- NULL
  high_cor_men <- data.frame()
})
```

**Purpose**: Identifies multicollinearity among alpine features and establishes baseline correlation patterns.

**Correlation Analysis Features**:
- **Multicollinearity Detection**: Identifies features with |r| > 0.7 that may cause modeling issues
- **Alpine-Specific Patterns**: Reveals relationships between different alpine disciplines
- **Quality Assurance**: Validates correlation matrix integrity and handles edge cases
- **Baseline Establishment**: Provides correlation foundation for other selection methods

##### 4b. LASSO Regularization
```r
# 2. LASSO REGULARIZATION with validation
cat("2. ALPINE LASSO REGULARIZATION:\n")
lasso_selected_men <- character(0)
tryCatch({
  set.seed(42)
  
  # Prepare data for LASSO
  x_men <- as.matrix(train_men[all_features_men])
  y_men <- train_men$Pct_of_Max_Points
  
  # Validate data for LASSO
  if (any(!is.finite(x_men))) {
    warning("Non-finite values in alpine feature matrix for LASSO")
  }
  if (any(!is.finite(y_men))) {
    warning("Non-finite values in alpine target variable for LASSO")
  }
  
  cv_lasso_men <- cv.glmnet(x_men, y_men, alpha = 1, nfolds = 5)
  best_lambda_men <- cv_lasso_men$lambda.min
  lasso_coef_men <- coef(cv_lasso_men, s = best_lambda_men)
  
  lasso_selected_men <- rownames(lasso_coef_men)[which(lasso_coef_men != 0)][-1]  # Remove intercept
  
  if (length(lasso_selected_men) > 0) {
    cat("Alpine LASSO selected features:\n")
    for (feature in lasso_selected_men) {
      coef_val <- lasso_coef_men[feature, 1]
      cat(sprintf("  %s: %.4f\n", feature, coef_val))
    }
  } else {
    cat("✓ No features selected by alpine LASSO (may indicate weak predictors)\n")
  }
  
  cat(sprintf("Best lambda: %.6f\n", best_lambda_men))
  
}, error = function(e) {
  cat("Error in alpine LASSO analysis:", e$message, "\n")
  lasso_selected_men <- character(0)
})
```

**Purpose**: Uses L1 regularization to identify alpine features that contribute most to prediction accuracy while preventing overfitting.

**LASSO Selection Features**:
- **Automatic Feature Selection**: LASSO naturally selects most predictive alpine features
- **Overfitting Prevention**: L1 regularization reduces model complexity for alpine data
- **Cross-Validation**: 5-fold CV optimizes lambda parameter for alpine-specific patterns
- **Coefficient Reporting**: Shows feature importance magnitude and direction
- **Reproducibility**: Fixed random seed ensures consistent results across runs

##### 4c. Boruta Feature Selection
```r
# 3. BORUTA FEATURE SELECTION with validation
cat("3. ALPINE BORUTA FEATURE SELECTION:\n")
boruta_selected_men <- character(0)
tryCatch({
  if (length(all_features_men) < 2) {
    cat("Insufficient alpine features for Boruta analysis\n")
  } else {
    set.seed(42)
    boruta_men <- Boruta(as.formula(paste("Pct_of_Max_Points ~", paste(all_features_men, collapse = " + "))), 
                         data = train_men, doTrace = 0)
    
    boruta_selected_men <- names(boruta_men$finalDecision)[boruta_men$finalDecision == "Confirmed"]
    
    if (length(boruta_selected_men) > 0) {
      cat("Alpine Boruta confirmed features:\n")
      for (feature in boruta_selected_men) {
        cat(sprintf("  %s\n", feature))
      }
    } else {
      cat("✓ No features confirmed by alpine Boruta\n")
    }
    
    # Check for tentative features
    tentative_men <- names(boruta_men$finalDecision)[boruta_men$finalDecision == "Tentative"]
    if (length(tentative_men) > 0) {
      cat("Alpine Boruta tentative features:\n")
      for (feature in tentative_men) {
        cat(sprintf("  %s (tentative)\n", feature))
      }
    }
  }
}, error = function(e) {
  cat("Error in alpine Boruta analysis:", e$message, "\n")
  boruta_selected_men <- character(0)
})
```

**Purpose**: Uses random forest-based all-relevant feature selection to identify all alpine features that have genuine predictive value.

**Boruta Selection Features**:
- **All-Relevant Selection**: Identifies all genuinely useful alpine features, not just best subset
- **Statistical Rigor**: Uses permutation testing to validate feature importance against random chance
- **Random Forest Foundation**: Leverages ensemble method strengths for alpine data patterns
- **Tentative Feature Handling**: Provides uncertainty quantification for borderline alpine features
- **Robust to Interactions**: Captures complex relationships between alpine disciplines

##### 4d. Exhaustive Search
```r
# 4. EXHAUSTIVE SEARCH with validation
cat("4. ALPINE EXHAUSTIVE SEARCH:\n")
leaps_selected_men <- character(0)
tryCatch({
  if (length(all_features_men) < 2) {
    cat("Insufficient alpine features for exhaustive search\n")
  } else if (length(all_features_men) > 8) {
    cat("Too many alpine features for exhaustive search - using best subset\n")
    leaps_men <- regsubsets(as.formula(paste("Pct_of_Max_Points ~", paste(all_features_men, collapse = " + "))), 
                           data = train_men, nvmax = min(8, length(all_features_men)))
  } else {
    leaps_men <- regsubsets(as.formula(paste("Pct_of_Max_Points ~", paste(all_features_men, collapse = " + "))), 
                           data = train_men, really.big = TRUE)
  }
  
  if (exists("leaps_men")) {
    summary_leaps_men <- summary(leaps_men)
    best_model_size <- which.max(summary_leaps_men$adjr2)
    leaps_selected_men <- names(which(summary_leaps_men$which[best_model_size, -1]))  # Remove intercept
    
    if (length(leaps_selected_men) > 0) {
      cat("Alpine exhaustive search selected features (best adj R²):\n")
      for (feature in leaps_selected_men) {
        cat(sprintf("  %s\n", feature))
      }
      cat(sprintf("Best model size: %d features, Adj R²: %.4f\n", 
                  best_model_size, summary_leaps_men$adjr2[best_model_size]))
    } else {
      cat("✓ No features selected by alpine exhaustive search\n")
    }
  }
}, error = function(e) {
  cat("Error in alpine exhaustive search:", e$message, "\n")
  leaps_selected_men <- character(0)
})
```

**Purpose**: Performs exhaustive search for optimal alpine feature combinations using adjusted R-squared optimization.

**Exhaustive Search Features**:
- **Optimal Subset Identification**: Finds best alpine feature combination for linear prediction
- **Adjusted R² Optimization**: Balances model fit with complexity for alpine data
- **Computational Efficiency**: Limits search to 8 features when full search impractical
- **Model Size Reporting**: Provides transparency about selected model complexity
- **Linear Relationship Focus**: Optimized for linear relationships in alpine performance data

#### 5. Consensus Feature Selection and Final Integration
```r
# 5. CONSENSUS FEATURE SELECTION
cat("5. ALPINE CONSENSUS FEATURE SELECTION:\n")

all_selected_men <- c(lasso_selected_men, boruta_selected_men, leaps_selected_men)
if (length(all_selected_men) > 0) {
  feature_counts_men <- table(all_selected_men)
  consensus_men <- names(feature_counts_men)[feature_counts_men >= 2]  # Features selected by 2+ methods
  
  if (length(consensus_men) > 0) {
    cat("Alpine consensus features (selected by 2+ methods):\n")
    for (feature in consensus_men) {
      count <- feature_counts_men[feature]
      methods <- c(
        if (feature %in% lasso_selected_men) "LASSO" else NULL,
        if (feature %in% boruta_selected_men) "Boruta" else NULL,
        if (feature %in% leaps_selected_men) "Exhaustive" else NULL
      )
      cat(sprintf("  %s (%d methods: %s)\n", feature, count, paste(methods, collapse = ", ")))
    }
  } else {
    cat("No alpine consensus features - using union of all methods\n")
    consensus_men <- unique(all_selected_men)
  }
} else {
  cat("No features selected by any method - using top correlated features\n")
  if (!is.null(cor_matrix_men) && "Pct_of_Max_Points" %in% names(train_men)) {
    target_cors <- cor(train_men[all_features_men], train_men$Pct_of_Max_Points, use = "complete.obs")
    consensus_men <- names(sort(abs(target_cors), decreasing = TRUE))[1:min(3, length(all_features_men))]
  } else {
    consensus_men <- all_features_men[1:min(3, length(all_features_men))]
  }
}

final_features_men <- consensus_men
cat(sprintf("Final alpine features for men: %s\n", paste(final_features_men, collapse = ", ")))
```

**Purpose**: Integrates results from multiple feature selection methods to create robust, consensus-based feature sets for alpine skiing prediction.

**Consensus Strategy**:
- **Multi-Method Integration**: Combines LASSO, Boruta, and exhaustive search results
- **Robust Selection**: Prioritizes features selected by 2+ methods for reliability
- **Fallback Mechanisms**: Uses union of methods or correlation-based selection when consensus fails
- **Method Transparency**: Reports which methods selected each consensus feature
- **Quality Assurance**: Ensures at least some features selected for model building

#### 6. Cross-Gender Feature Selection Replication
The same comprehensive feature selection process is applied to women's alpine data:

```r
cat("\n=== COMPREHENSIVE ALPINE FEATURE SELECTION FOR LADIES ===\n")

# Repeat the same process for ladies with alpine-specific adaptations
# 1. CORRELATION ANALYSIS
# 2. LASSO REGULARIZATION  
# 3. BORUTA FEATURE SELECTION
# 4. EXHAUSTIVE SEARCH
# 5. CONSENSUS FEATURE SELECTION
```

**Purpose**: Ensures consistent and thorough feature selection across both men's and women's alpine skiing datasets.

**Cross-Gender Consistency**:
- **Parallel Processing**: Applies identical methodology to both datasets
- **Gender-Specific Optimization**: Allows for different optimal feature sets between men's and women's alpine skiing
- **Comparative Analysis**: Enables comparison of feature importance patterns across genders
- **Independent Validation**: Validates feature selection robustness across different athlete populations

#### 7. Feature Selection Results Storage and Summary
```r
cat("\n=== ALPINE FEATURE SELECTION SUMMARY ===\n")
cat(sprintf("Men's final alpine features (%d): %s\n", length(final_features_men), paste(final_features_men, collapse = ", ")))
cat(sprintf("Ladies final alpine features (%d): %s\n", length(final_features_ladies), paste(final_features_ladies, collapse = ", ")))

# Store feature selection results for later use
feature_selection_results_men <- list(
  lasso = lasso_selected_men,
  boruta = boruta_selected_men,
  exhaustive = leaps_selected_men,
  final = final_features_men
)

feature_selection_results_ladies <- list(
  lasso = lasso_selected_ladies,
  boruta = boruta_selected_ladies,
  exhaustive = leaps_selected_ladies,
  final = final_features_ladies
)

cat("\n=== COMPREHENSIVE ALPINE FEATURE SELECTION COMPLETE ===\n")
```

**Purpose**: Summarizes feature selection results and stores detailed outcomes for subsequent modeling and analysis.

**Results Documentation**:
- **Final Feature Sets**: Reports consensus features for both men's and women's alpine skiing
- **Method-Specific Results**: Preserves individual method results for analysis and debugging
- **Structured Storage**: Organizes results in lists for programmatic access in downstream modeling
- **Comprehensive Summary**: Provides clear overview of feature selection outcomes

### Alpine Feature Selection Design Considerations

#### Multi-Discipline Feature Space
Alpine skiing's unique feature requirements:
- **Discipline-Specific ELOs**: Individual ratings for Downhill, Super G, Giant Slalom, Slalom, Combined
- **Aggregate Category Features**: Technical vs Speed discipline groupings
- **Performance History**: Previous season success metrics and trend indicators
- **Demographic Factors**: Age and experience considerations

#### Method Complementarity
The multi-method approach leverages different selection strengths:
- **LASSO**: Linear relationship optimization with automatic feature selection
- **Boruta**: All-relevant features with statistical rigor and interaction capture
- **Exhaustive Search**: Optimal subset identification for linear prediction
- **Consensus Integration**: Robust feature sets through method agreement

#### Alpine-Specific Adaptations
- **Season-Aware Training**: Uses 2016-2025 timeframe for modern alpine competitive dynamics
- **Discipline Balance**: Ensures representation across alpine's diverse competitive structure
- **Performance Standardization**: Works with percentage of maximum points for cross-season comparability
- **Gender-Specific Optimization**: Allows for different optimal features between men's and women's alpine skiing

### Error Handling and Quality Assurance
- **Input Validation**: Comprehensive checks for data availability and quality
- **Method-Specific Validation**: Individual error handling for each selection method
- **Consensus Robustness**: Multiple fallback strategies when consensus fails
- **Cross-Dataset Consistency**: Parallel processing ensures consistent methodology
- **Results Documentation**: Detailed tracking of selection outcomes and method performance

This alpine feature selection section creates optimized, statistically validated feature sets that capture the most predictive aspects of alpine skiing performance while maintaining robustness across different modeling approaches and athlete populations.

## Section: {r gam-model} - Alpine GAM Model Building & Prediction

### Purpose
This section builds Generalized Additive Models (GAM) for alpine skiing season prediction using consensus-selected features, validates model performance, and generates 2026 season predictions with comprehensive error handling and diagnostic evaluation.

### Implementation Details

#### 1. GAM Model Construction and Input Validation
```r
cat("=== GAM MODEL BUILDING & VALIDATION ===\n")

# Build GAM models using consensus-selected features with comprehensive validation
cat("\n--- GAM Model Construction ---\n")

# Validate inputs for GAM model building
if (!exists("final_features_men") || !exists("final_features_ladies")) {
  stop("Final features not defined - ensure feature selection completed successfully")
}

if (!exists("train_men") || !exists("train_ladies")) {
  stop("Training data not available - ensure data preparation completed successfully")
}

cat(sprintf("Input validation: Men %d features, Ladies %d features\n", 
            length(final_features_men), length(final_features_ladies)))

cat(sprintf("Training data: Men %d rows, Ladies %d rows\n", 
            nrow(train_men), nrow(train_ladies)))
```

**Purpose**: Establishes comprehensive validation framework for GAM model construction using alpine-specific consensus features.

**Input Validation Features**:
- **Feature Availability Check**: Ensures consensus feature selection completed successfully
- **Training Data Validation**: Confirms processed training data is available for modeling
- **Data Size Reporting**: Reports feature counts and training dataset sizes for both genders
- **Dependency Verification**: Validates that prerequisite processing steps completed successfully

#### 2. Men's GAM Model Construction with Robust Error Handling
```r
# Build GAM formula for Men using validated features
cat("\n--- Men's GAM Model ---\n")
men_gam_model <- NULL
tryCatch({
  if(length(final_features_men) > 0) {
    # Validate features exist in training data
    missing_features_men <- setdiff(final_features_men, names(train_men))
    if (length(missing_features_men) > 0) {
      cat("Warning: Missing features in men's training data:", paste(missing_features_men, collapse = ", "), "\n")
      final_features_men <- intersect(final_features_men, names(train_men))
    }
    
    if (length(final_features_men) > 0) {
      smooth_terms_men <- paste("s(", final_features_men, ")", collapse = " + ")
      gam_formula_men <- as.formula(paste("Pct_of_Max_Points ~", smooth_terms_men))
      cat("Men's GAM Formula (Validated Features):\n")
      print(gam_formula_men)
      
      # Check for sufficient data points per feature
      min_obs_per_feature <- 10
      required_obs <- length(final_features_men) * min_obs_per_feature
      if (nrow(train_men) < required_obs) {
        warning(sprintf("Limited observations for men's GAM (%d obs, %d features, recommend %d+ obs)", 
                       nrow(train_men), length(final_features_men), required_obs))
      }
      
      # Build GAM with error handling
      men_gam_model <- gam(gam_formula_men, data = train_men)
      cat(sprintf("✓ Men's GAM model built successfully with %d features\n", length(final_features_men)))
    }
  }
}, error = function(e) {
  cat("Error building men's GAM model:", e$message, "\n")
  cat("Attempting fallback to core features...\n")
  
  # Fallback to proven core features
  core_features_men <- intersect(c("Prev_Pct_of_Max_Points", "Prev_Pelo", "Prev_Tech", "Prev_Speed"), names(train_men))
  if (length(core_features_men) >= 2) {
    fallback_formula_men <- paste("Pct_of_Max_Points ~", paste("s(", core_features_men, ")", collapse = " + "))
    men_gam_model <- gam(as.formula(fallback_formula_men), data = train_men)
    final_features_men <- core_features_men
    cat("✓ Men's GAM fallback model built with core features\n")
  } else {
    stop("Cannot build men's GAM model - insufficient core features available")
  }
})
```

**Purpose**: Constructs robust GAM models for men's alpine skiing with comprehensive error handling and fallback strategies.

**GAM Construction Features**:
- **Feature Validation**: Confirms selected features exist in training data before model building
- **Formula Generation**: Creates GAM formula with smooth terms for non-linear relationships
- **Data Sufficiency Check**: Validates adequate observations per feature (10:1 ratio recommended)
- **Smooth Term Integration**: Uses `s()` notation for capturing non-linear alpine performance relationships
- **Robust Error Handling**: Implements fallback to core alpine features when consensus features fail

**Fallback Strategy**:
- **Core Features**: Falls back to proven alpine predictors (Prev_Pct_of_Max_Points, Prev_Pelo, Prev_Tech, Prev_Speed)
- **Minimum Requirements**: Requires at least 2 core features for fallback model
- **Graceful Degradation**: Ensures model building succeeds even with limited feature availability

#### 3. Ladies GAM Model Construction with Parallel Processing
```r
# Build GAM formula for Ladies using validated features
cat("\n--- Ladies GAM Model ---\n")
ladies_gam_model <- NULL
tryCatch({
  if(length(final_features_ladies) > 0) {
    # Validate features exist in training data
    missing_features_ladies <- setdiff(final_features_ladies, names(train_ladies))
    if (length(missing_features_ladies) > 0) {
      cat("Warning: Missing features in ladies training data:", paste(missing_features_ladies, collapse = ", "), "\n")
      final_features_ladies <- intersect(final_features_ladies, names(train_ladies))
    }
    
    if (length(final_features_ladies) > 0) {
      smooth_terms_ladies <- paste("s(", final_features_ladies, ")", collapse = " + ")
      gam_formula_ladies <- as.formula(paste("Pct_of_Max_Points ~", smooth_terms_ladies))
      cat("Ladies GAM Formula (Validated Features):\n")
      print(gam_formula_ladies)
      
      # Check for sufficient data points per feature
      min_obs_per_feature <- 10
      required_obs <- length(final_features_ladies) * min_obs_per_feature
      if (nrow(train_ladies) < required_obs) {
        warning(sprintf("Limited observations for ladies GAM (%d obs, %d features, recommend %d+ obs)", 
                       nrow(train_ladies), length(final_features_ladies), required_obs))
      }
      
      # Build GAM with error handling
      ladies_gam_model <- gam(gam_formula_ladies, data = train_ladies)
      cat(sprintf("✓ Ladies GAM model built successfully with %d features\n", length(final_features_ladies)))
    }
  }
}, error = function(e) {
  cat("Error building ladies GAM model:", e$message, "\n")
  cat("Attempting fallback to core features...\n")
  
  # Fallback to proven core features
  core_features_ladies <- intersect(c("Prev_Pct_of_Max_Points", "Prev_Pelo", "Prev_Tech", "Prev_Speed"), names(train_ladies))
  if (length(core_features_ladies) >= 2) {
    fallback_formula_ladies <- paste("Pct_of_Max_Points ~", paste("s(", core_features_ladies, ")", collapse = " + "))
    ladies_gam_model <- gam(as.formula(fallback_formula_ladies), data = train_ladies)
    final_features_ladies <- core_features_ladies
    cat("✓ Ladies GAM fallback model built with core features\n")
  } else {
    stop("Cannot build ladies GAM model - insufficient core features available")
  }
})
```

**Purpose**: Constructs women's alpine GAM models using identical methodology to ensure cross-gender consistency and robustness.

**Parallel Processing Benefits**:
- **Consistent Methodology**: Uses same validation and construction process as men's models
- **Gender-Specific Optimization**: Allows for different optimal features between men's and women's alpine skiing
- **Independent Validation**: Validates model construction robustness across different athlete populations
- **Comparative Analysis**: Enables comparison of model performance patterns across genders

#### 4. Comprehensive GAM Model Performance Evaluation
```r
# Model performance evaluation with validation
cat("\n=== GAM MODEL PERFORMANCE EVALUATION ===\n")

# Men's GAM Model Performance
cat("--- Men's GAM Model Performance ---\n")
tryCatch({
  men_summary <- summary(men_gam_model)
  
  # Validate summary components exist
  if (is.null(men_summary$dev.expl)) {
    warning("Men's GAM deviance explained not available")
    men_dev_expl <- NA
  } else {
    men_dev_expl <- men_summary$dev.expl * 100
  }
  
  if (is.null(men_summary$r.sq)) {
    warning("Men's GAM R-squared not available")
    men_r_sq <- NA
  } else {
    men_r_sq <- men_summary$r.sq
  }
  
  if (is.null(men_gam_model$gcv.ubre)) {
    warning("Men's GAM GCV score not available")
    men_gcv <- NA
  } else {
    men_gcv <- men_gam_model$gcv.ubre
  }
  
  cat(sprintf("Deviance Explained: %.2f%%\n", men_dev_expl))
  cat(sprintf("Adjusted R-squared: %.3f\n", men_r_sq))
  cat(sprintf("GCV Score: %.4f\n", men_gcv))
  
  # Validate model performance
  if (!is.na(men_dev_expl) && men_dev_expl < 10) {
    warning("Men's GAM has very low deviance explained (<10%)")
  }
  if (!is.na(men_r_sq) && men_r_sq < 0.1) {
    warning("Men's GAM has very low R-squared (<0.1)")
  }
  
  # Model fit statistics
  cat(sprintf("Observations: %d\n", nrow(men_gam_model$model)))
  cat(sprintf("Effective degrees of freedom: %.1f\n", sum(men_gam_model$edf)))
  
}, error = function(e) {
  cat("Error evaluating men's GAM performance:", e$message, "\n")
})
```

**Purpose**: Provides comprehensive evaluation of GAM model performance using multiple alpine-specific metrics.

**Performance Metrics**:
- **Deviance Explained**: Measures how much variance the model explains in alpine performance data
- **Adjusted R-squared**: Accounts for model complexity in goodness-of-fit assessment
- **GCV Score**: Generalized Cross-Validation score for model selection and validation
- **Effective Degrees of Freedom**: Measures model complexity for alpine feature relationships

**Quality Validation**:
- **Performance Thresholds**: Warns if deviance explained <10% or R-squared <0.1
- **Component Validation**: Ensures all performance metrics are available and valid
- **Model Complexity Assessment**: Reports observations and effective degrees of freedom

#### 5. Feature Importance Analysis Through Effective Degrees of Freedom
```r
# Feature importance from GAM (edf values) with validation
cat("\n--- Feature Importance Analysis ---\n")

# Men's Feature Importance
cat("Men's GAM Feature Importance (Effective Degrees of Freedom):\n")
tryCatch({
  if (!is.null(men_summary$s.table) && nrow(men_summary$s.table) > 0) {
    men_edf <- men_summary$s.table[,"edf"]
    names(men_edf) <- rownames(men_summary$s.table)
    
    # Validate EDF values
    if (any(is.na(men_edf))) {
      warning("Some men's GAM EDF values are NA")
      men_edf <- men_edf[!is.na(men_edf)]
    }
    
    if (length(men_edf) > 0) {
      edf_sorted <- sort(men_edf, decreasing = TRUE)
      for (i in 1:length(edf_sorted)) {
        cat(sprintf("  %s: %.3f\n", names(edf_sorted)[i], edf_sorted[i]))
      }
      
      # Identify most complex features (high EDF suggests non-linear relationship)
      high_edf_features <- names(men_edf[men_edf > 3])
      if (length(high_edf_features) > 0) {
        cat("Features with non-linear relationships (EDF > 3):", paste(high_edf_features, collapse = ", "), "\n")
      }
    } else {
      cat("No valid EDF values for men's model\n")
    }
  } else {
    cat("No smooth terms in men's GAM model\n")
  }
}, error = function(e) {
  cat("Error analyzing men's feature importance:", e$message, "\n")
})
```

**Purpose**: Analyzes feature importance in alpine GAM models using Effective Degrees of Freedom to understand non-linear relationships.

**EDF Analysis Features**:
- **Non-linearity Detection**: High EDF values (>3) indicate strong non-linear relationships in alpine performance
- **Feature Ranking**: Sorts features by complexity to identify most important alpine predictors
- **Complexity Assessment**: EDF ≈1 suggests linear relationship, higher values indicate more complex curves
- **Alpine-Specific Interpretation**: Helps understand which alpine disciplines show non-linear performance patterns

#### 6. Comprehensive GAM Model Diagnostics
```r
# Model diagnostics with validation
cat("\n=== GAM MODEL DIAGNOSTICS ===\n")

# Men's GAM Model Diagnostics
cat("--- Men's GAM Model Diagnostics ---\n")
tryCatch({
  par(mfrow = c(2, 2))
  gam_check_men <- gam.check(men_gam_model, sub.caption = "Men's GAM Diagnostics")
  
  # Extract and validate diagnostic information
  if (!is.null(gam_check_men)) {
    # Check for model convergence issues
    if ("converged" %in% names(men_gam_model) && !men_gam_model$converged) {
      warning("Men's GAM model did not converge properly")
    }
    
    # Check basis dimensions
    if ("p.table" %in% names(men_summary)) {
      basis_dims <- men_summary$s.table[,"k-index"]
      low_basis <- names(basis_dims[basis_dims < 0.1])
      if (length(low_basis) > 0) {
        warning(paste("Men's GAM features with potentially insufficient basis dimensions:", 
                     paste(low_basis, collapse = ", ")))
      }
    }
  }
  
  cat("✓ Men's GAM diagnostic plots generated\n")
  
}, error = function(e) {
  cat("Error generating men's GAM diagnostics:", e$message, "\n")
  # Reset plotting parameters
  par(mfrow = c(1, 1))
})
```

**Purpose**: Generates comprehensive diagnostic plots and validates GAM model assumptions for alpine skiing data.

**Diagnostic Features**:
- **Residual Analysis**: QQ plots and residual vs fitted plots for assumption validation
- **Convergence Validation**: Checks if GAM optimization converged properly for alpine data
- **Basis Dimension Assessment**: Validates smooth function basis dimensions are adequate
- **Visual Diagnostics**: Four-panel diagnostic plots for comprehensive model validation

#### 7. 2026 Season Prediction Framework
```r
# Predict for 2026 season using 2025 ELO values with comprehensive validation
cat("\n=== 2026 SEASON PREDICTIONS ===\n")

# Validate prediction data availability
cat("--- Prediction Data Preparation ---\n")

# Check for 2025 ELO data (end-of-season values)
men_2025 <- M_elo %>% 
  filter(Season == 2025) %>%
  group_by(Skier) %>%
  slice_tail(n = 1) %>%  # Get most recent record per skier (end-of-2025)
  ungroup()

ladies_2025 <- L_elo %>% 
  filter(Season == 2025) %>%
  group_by(Skier) %>%
  slice_tail(n = 1) %>%  # Get most recent record per skier (end-of-2025)
  ungroup()

# Rename columns to match GAM model expectations (Prev_* format)
cat("Renaming 2025 features to Prev_* format for GAM predictions...\n")
```

**Purpose**: Establishes comprehensive framework for generating 2026 alpine skiing season predictions using trained GAM models.

**Prediction Data Preparation**:
- **End-of-Season ELO**: Uses most recent 2025 ELO ratings as predictors for 2026 performance
- **Feature Alignment**: Renames 2025 ELO columns to match GAM model expected format (Prev_*)
- **Data Validation**: Ensures prediction data availability and quality before GAM prediction
- **Temporal Consistency**: Maintains proper time ordering for prediction validity

#### 8. Data Preprocessing for 2026 Predictions
```r
if (nrow(men_2025) > 0) {
  # First, remove existing Prev_* columns (which contain 2024 data)
  prev_cols_to_remove <- c("Prev_Pelo", "Prev_Downhill", "Prev_Super_G", "Prev_Giant_Slalom", 
                          "Prev_Slalom", "Prev_Combined", "Prev_Tech", "Prev_Speed", "Prev_Pct_of_Max_Points")
  existing_prev_cols <- intersect(prev_cols_to_remove, names(men_2025))
  if (length(existing_prev_cols) > 0) {
    cat("Removing existing Prev_* columns (2024 data):", paste(existing_prev_cols, collapse = ", "), "\n")
    men_2025 <- men_2025 %>% dplyr::select(-all_of(existing_prev_cols))
  }
  
  # Then rename current 2025 columns to Prev_* format
  men_2025 <- men_2025 %>%
    rename(
      Prev_Pelo = Pelo,
      Prev_Downhill = Downhill_Pelo,
      Prev_Super_G = `Super G_Pelo`,
      Prev_Giant_Slalom = `Giant Slalom_Pelo`,
      Prev_Slalom = Slalom_Pelo,
      Prev_Combined = Combined_Pelo,
      Prev_Tech = Tech_Pelo,
      Prev_Speed = Speed_Pelo,
      Prev_Pct_of_Max_Points = Pct_of_Max_Points
    )
}

# Apply quartile replacement to handle missing values in 2025 data
cat("Applying quartile replacement for missing values in 2025 prediction data...\n")

if (nrow(men_2025) > 0) {
  men_2025 <- men_2025 %>%
    group_by(Season) %>%
    mutate(
      Prev_Pelo = replace_na_with_quartile(Prev_Pelo),
      Prev_Downhill = replace_na_with_quartile(Prev_Downhill),
      Prev_Super_G = replace_na_with_quartile(Prev_Super_G),
      Prev_Giant_Slalom = replace_na_with_quartile(Prev_Giant_Slalom),
      Prev_Slalom = replace_na_with_quartile(Prev_Slalom),
      Prev_Combined = replace_na_with_quartile(Prev_Combined),
      Prev_Tech = replace_na_with_quartile(Prev_Tech),
      Prev_Speed = replace_na_with_quartile(Prev_Speed),
      Prev_Pct_of_Max_Points = replace_na_with_quartile(Prev_Pct_of_Max_Points)
    ) %>%
    ungroup()
}
```

**Purpose**: Implements robust data preprocessing for 2026 predictions with comprehensive missing value handling.

**Preprocessing Steps**:
- **Legacy Data Removal**: Removes outdated Prev_* columns containing 2024 data
- **Feature Renaming**: Converts 2025 ELO ratings to Prev_* format for GAM model compatibility
- **Missing Value Imputation**: Applies conservative quartile-based imputation for missing alpine ELO values
- **Discipline-Specific Treatment**: Handles missing values for each alpine discipline independently

#### 9. GAM-Based 2026 Prediction Generation
```r
# Men's 2026 Predictions
cat("\n--- Men's 2026 Predictions ---\n")
men_pred_data <- NULL
if(nrow(men_2025) > 0) {
  tryCatch({
    # Validate features are available in 2025 data
    available_features_men <- intersect(final_features_men, names(men_2025))
    missing_features_men <- setdiff(final_features_men, names(men_2025))
    
    if (length(missing_features_men) > 0) {
      cat("Warning: Missing features in men's 2025 data for prediction:", paste(missing_features_men, collapse = ", "), "\n")
    }
    
    if (length(available_features_men) > 0) {
      # Debug: Show exact GAM model input for Marcel Hirscher
      if ("Marcel Hirscher" %in% men_2025$Skier) {
        hirscher_idx <- which(men_2025$Skier == "Marcel Hirscher")
        cat("\n=== DEBUG: Marcel Hirscher GAM Model Input ===\n")
        cat("Selected features for GAM:", paste(final_features_men, collapse = ", "), "\n")
        hirscher_model_data <- men_2025[hirscher_idx, c("Skier", final_features_men), drop = FALSE]
        print(hirscher_model_data)
      }
      
      # Use only available features for prediction
      pred_2026_men <- predict(men_gam_model, newdata = men_2025, se.fit = TRUE)
      
      # Validate predictions
      if (any(!is.finite(pred_2026_men$fit))) {
        warning("Some men's 2026 predictions are non-finite")
        pred_2026_men$fit[!is.finite(pred_2026_men$fit)] <- NA
      }
      
      men_pred_data <- men_2025 %>%
        mutate(
          Predicted_Pct_2026 = pred_2026_men$fit,
          Prediction_SE = pred_2026_men$se.fit,
          Lower_CI = Predicted_Pct_2026 - 1.96 * Prediction_SE,
          Upper_CI = Predicted_Pct_2026 + 1.96 * Prediction_SE
        ) %>%
        filter(!is.na(Predicted_Pct_2026)) %>%
        arrange(desc(Predicted_Pct_2026))
      
      cat(sprintf("✓ Men's 2026 predictions generated for %d athletes\n", nrow(men_pred_data)))
      cat(sprintf("Top predicted: %s (%.2f%% of max points)\n", 
                  men_pred_data$Skier[1], men_pred_data$Predicted_Pct_2026[1] * 100))
    }
  }, error = function(e) {
    cat("Error generating men's 2026 predictions:", e$message, "\n")
  })
}
```

**Purpose**: Generates 2026 season predictions with confidence intervals and comprehensive validation.

**Prediction Features**:
- **Feature Validation**: Ensures required features are available in 2025 prediction data
- **Debug Output**: Provides detailed model input for star athletes (Marcel Hirscher, Lara Colturi)
- **Uncertainty Quantification**: Generates standard errors and 95% confidence intervals
- **Prediction Validation**: Checks for non-finite predictions and handles gracefully
- **Results Ranking**: Sorts predictions by expected performance for easy interpretation

### Alpine GAM-Specific Design Considerations

#### Non-Linear Relationship Modeling
GAM models excel at capturing alpine skiing's complex performance patterns:
- **Smooth Functions**: Use spline smoothing to model non-linear relationships between ELO ratings and performance
- **Discipline Interactions**: Capture complex relationships between different alpine disciplines
- **Performance Curves**: Model diminishing returns and threshold effects in alpine performance
- **Age Effects**: Capture non-linear age-performance relationships in alpine skiing

#### Alpine-Specific Model Validation
- **EDF Interpretation**: High EDF values indicate complex non-linear relationships specific to alpine disciplines
- **Convergence Monitoring**: Ensures GAM optimization converges properly for alpine data patterns
- **Basis Dimension Validation**: Confirms adequate flexibility for modeling alpine performance curves
- **Cross-Gender Consistency**: Validates model construction robustness across different athlete populations

#### Prediction Robustness
- **Feature Alignment**: Ensures 2025 ELO data properly formatted for GAM prediction
- **Missing Value Handling**: Conservative quartile-based imputation maintains prediction reliability
- **Uncertainty Quantification**: Confidence intervals provide prediction reliability assessment
- **Star Athlete Debugging**: Detailed output for high-profile athletes ensures prediction transparency

### Error Handling and Quality Assurance
- **Comprehensive Input Validation**: Validates all prerequisites before GAM construction
- **Robust Fallback Strategies**: Core feature fallbacks ensure model building succeeds
- **Performance Monitoring**: Multiple metrics assess model quality and reliability
- **Prediction Validation**: Extensive checks ensure prediction quality and interpretability
- **Diagnostic Integration**: Built-in diagnostic plots validate model assumptions

This alpine GAM modeling section creates sophisticated, non-linear prediction models that capture the complex relationships inherent in alpine skiing performance while maintaining robustness and providing comprehensive uncertainty quantification for 2026 season predictions.

## Section: {r odds-setup} - Alpine Odds Framework & Categorical Outcome Preparation

### Purpose
This section establishes the comprehensive framework for odds calculation in alpine skiing by creating categorical performance outcomes, validating ranking systems, and preparing prediction data for statistical odds modeling across multiple performance thresholds.

### Implementation Details

#### 1. Training Data Validation for Odds Calculation
```r
cat("=== ODDS SETUP & VALIDATION ===\n")

# Validate training data availability for odds calculations
cat("\n--- Training Data Validation for Odds ---\n")

if (!exists("train_men") || !exists("train_ladies")) {
  stop("Training data not available - ensure previous sections completed successfully")
}

if (nrow(train_men) == 0) {
  stop("Men's training data is empty")
}
if (nrow(train_ladies) == 0) {
  stop("Ladies training data is empty") 
}

cat(sprintf("Training data for odds: Men %d rows, Ladies %d rows\n", nrow(train_men), nrow(train_ladies)))

# Validate required columns exist
required_odds_cols <- c("Pct_of_Max_Points", "Season")
missing_men_cols <- setdiff(required_odds_cols, names(train_men))
missing_ladies_cols <- setdiff(required_odds_cols, names(train_ladies))

if (length(missing_men_cols) > 0) {
  stop(sprintf("Men's training data missing required columns for odds: %s", paste(missing_men_cols, collapse = ", ")))
}
if (length(missing_ladies_cols) > 0) {
  stop(sprintf("Ladies training data missing required columns for odds: %s", paste(missing_ladies_cols, collapse = ", ")))
}
```

**Purpose**: Validates comprehensive training data availability and quality for alpine skiing odds calculation framework.

**Data Validation Features**:
- **Training Data Existence**: Confirms processed training data is available from previous sections
- **Empty Dataset Protection**: Prevents odds calculation with insufficient data
- **Required Column Validation**: Ensures essential variables (Pct_of_Max_Points, Season) are present
- **Cross-Gender Validation**: Validates data availability for both men's and women's alpine skiing

**Quality Assurance**:
- **Data Size Reporting**: Reports training dataset sizes for transparency
- **Dependency Verification**: Ensures prerequisite processing steps completed successfully
- **Error Prevention**: Stops processing if critical data components are missing

#### 2. Season-Based Ranking System Implementation
```r
# Add Place column based on rankings within each season with validation
cat("\n--- Season Ranking Calculation ---\n")

tryCatch({
  df_place <- train_men %>%
    group_by(Season) %>%
    mutate(Place = rank(-Pct_of_Max_Points, ties.method = "min")) %>%
    ungroup()
  
  cat(sprintf("✓ Men's place rankings calculated: %d rows\n", nrow(df_place)))
}, error = function(e) {
  stop("Failed to calculate men's place rankings: ", e$message)
})

tryCatch({
  df_place_ladies <- train_ladies %>%
    group_by(Season) %>%
    mutate(Place = rank(-Pct_of_Max_Points, ties.method = "min")) %>%
    ungroup()
    
  cat(sprintf("✓ Ladies place rankings calculated: %d rows\n", nrow(df_place_ladies)))
}, error = function(e) {
  stop("Failed to calculate ladies place rankings: ", e$message)
})

# Validate Place column creation
place_na_men <- sum(is.na(df_place$Place))
place_na_ladies <- sum(is.na(df_place_ladies$Place))

if (place_na_men > 0) {
  warning(sprintf("Men's Place column has %d NA values", place_na_men))
}
if (place_na_ladies > 0) {
  warning(sprintf("Ladies Place column has %d NA values", place_na_ladies))
}

# Validate ranking ranges
men_place_range <- range(df_place$Place, na.rm = TRUE)
ladies_place_range <- range(df_place_ladies$Place, na.rm = TRUE)

cat(sprintf("Men's Place range: %d - %d\n", men_place_range[1], men_place_range[2]))
cat(sprintf("Ladies Place range: %d - %d\n", ladies_place_range[1], ladies_place_range[2]))
```

**Purpose**: Implements robust season-based ranking system that creates competitive context for alpine skiing odds calculation.

**Ranking System Features**:
- **Season-Based Rankings**: Rankings calculated within each season to account for competitive context
- **Performance-Based Ordering**: Uses negative Pct_of_Max_Points for descending order (best performers ranked 1st)
- **Tie Handling**: Uses "min" method for consistent tie-breaking in alpine performance rankings
- **Cross-Gender Processing**: Applies identical ranking methodology to both men's and women's data

**Validation Framework**:
- **Missing Value Detection**: Identifies and reports any NA values in ranking calculations
- **Range Validation**: Confirms ranking ranges are logical (starting from 1)
- **Error Handling**: Robust error handling ensures ranking calculation succeeds or fails gracefully

#### 3. Comprehensive Season Ranking Validation
```r
# Debug and validate season rankings
cat("\n--- Season Ranking Validation ---\n")

# Check ladies data distribution
cat("Ladies Pct_of_Max_Points distribution:\n")
ladies_pct_summary <- summary(train_ladies$Pct_of_Max_Points)
print(ladies_pct_summary)

# Validate no negative or extreme values
if (any(train_ladies$Pct_of_Max_Points < 0, na.rm = TRUE)) {
  warning("Ladies data contains negative Pct_of_Max_Points values")
}
if (any(train_ladies$Pct_of_Max_Points > 2, na.rm = TRUE)) {
  warning("Ladies data contains very high Pct_of_Max_Points values (>200%)")
}

cat("Ladies Place distribution:\n")
ladies_place_table <- table(df_place_ladies$Place)
print(head(ladies_place_table, 10))

cat("Ladies seasons distribution:\n")
ladies_season_table <- table(df_place_ladies$Season)
print(ladies_season_table)

# Check for balanced season representation
if (any(ladies_season_table < 5)) {
  seasons_low_n <- names(ladies_season_table[ladies_season_table < 5])
  warning(sprintf("Ladies seasons with <5 observations: %s", paste(seasons_low_n, collapse = ", ")))
}

# Sample rankings validation
cat("Sample ladies season rankings (first 15):\n")
sample_rankings <- df_place_ladies %>% 
  arrange(Season, Place) %>% 
  dplyr::select(Season, Skier, Pct_of_Max_Points, Place) %>%
  head(15)
print(sample_rankings)
```

**Purpose**: Provides comprehensive validation of alpine skiing ranking system quality and distribution characteristics.

**Validation Components**:
- **Performance Distribution Analysis**: Examines Pct_of_Max_Points distribution for data quality
- **Extreme Value Detection**: Identifies negative or unrealistically high performance values
- **Ranking Distribution**: Analyzes place distribution to understand competitive structure
- **Season Balance Assessment**: Ensures adequate representation across all alpine skiing seasons
- **Sample Validation**: Provides concrete examples of ranking calculation results

**Quality Checks**:
- **Data Range Validation**: Confirms performance percentages are within expected bounds (0-200%)
- **Season Representation**: Warns about seasons with insufficient data (<5 observations)
- **Ranking Logic Verification**: Shows sample rankings to validate correct ordering

#### 4. Categorical Outcome Framework Creation
```r
# Create categorical outcomes for different cutoffs with validation
cat("\n--- Categorical Outcome Creation ---\n")

tryCatch({
  df_place <- df_place %>%
    mutate(
      Win = factor(ifelse(Place <= 1, 1, 0)),
      TopThree = factor(ifelse(Place <= 3, 1, 0)),  # Binary: 1=Top3, 0=Not Top3
      Top5 = factor(ifelse(Place <= 5, 1, 0)),
      Top10 = factor(ifelse(Place <= 10, 1, 0)),
      Top30 = factor(ifelse(Place <= 30, 1, 0))
    )
  
  cat("✓ Men's categorical outcomes created\n")
}, error = function(e) {
  stop("Failed to create men's categorical outcomes: ", e$message)
})

tryCatch({
  df_place_ladies <- df_place_ladies %>%
    mutate(
      Win = factor(ifelse(Place <= 1, 1, 0)),
      TopThree = factor(ifelse(Place <= 3, 1, 0)),  # Binary: 1=Top3, 0=Not Top3
      Top5 = factor(ifelse(Place <= 5, 1, 0)),
      Top10 = factor(ifelse(Place <= 10, 1, 0)),
      Top30 = factor(ifelse(Place <= 30, 1, 0))
    )
  
  cat("✓ Ladies categorical outcomes created\n")
}, error = function(e) {
  stop("Failed to create ladies categorical outcomes: ", e$message)
})
```

**Purpose**: Creates comprehensive categorical outcome framework for alpine skiing odds calculation across multiple performance thresholds.

**Categorical Outcome Structure**:
- **Win**: Season victory (Place <= 1) - captures championship-level performance
- **TopThree**: Podium finish (Place <= 3) - represents elite consistency in alpine skiing
- **Top5**: Elite performance (Place <= 5) - broader elite tier for alpine competitive analysis
- **Top10**: Strong performance (Place <= 10) - competitive alpine skiing threshold
- **Top30**: Points-scoring finish (Place <= 30) - alpine World Cup points eligibility

**Alpine-Specific Considerations**:
- **Championship Focus**: Win category captures seasonal dominance in alpine skiing
- **Podium Emphasis**: TopThree aligns with alpine skiing's podium ceremony tradition
- **Points Threshold**: Top30 corresponds to alpine World Cup points system (top 30 score points)
- **Factor Encoding**: Binary factors (0/1) enable logistic regression modeling for odds calculation

#### 5. Comprehensive Categorical Outcome Validation
```r
# Validate categorical outcome creation
cat("\n--- Categorical Outcome Validation ---\n")

# Check TopThree creation for ladies
cat("Ladies Place vs TopThree validation:\n")
topthree_crosstab <- table(df_place_ladies$Place, df_place_ladies$TopThree, useNA = "always")
print(topthree_crosstab[1:min(10, nrow(topthree_crosstab)), ])

# Validate factor levels
expected_levels <- c("0", "1")
targets <- c("Win", "TopThree", "Top5", "Top10", "Top30")

for (target in targets) {
  men_levels <- levels(df_place[[target]])
  ladies_levels <- levels(df_place_ladies[[target]])
  
  if (!all(expected_levels %in% men_levels)) {
    warning(sprintf("Men's %s missing expected levels: %s", target, paste(setdiff(expected_levels, men_levels), collapse = ", ")))
  }
  if (!all(expected_levels %in% ladies_levels)) {
    warning(sprintf("Ladies %s missing expected levels: %s", target, paste(setdiff(expected_levels, ladies_levels), collapse = ", ")))
  }
  
  # Check for class imbalance
  men_table <- table(df_place[[target]])
  ladies_table <- table(df_place_ladies[[target]])
  
  men_minority_pct <- min(men_table) / sum(men_table) * 100
  ladies_minority_pct <- min(ladies_table) / sum(ladies_table) * 100
  
  cat(sprintf("%s class balance: Men %.1f%% minority, Ladies %.1f%% minority\n", 
              target, men_minority_pct, ladies_minority_pct))
  
  if (men_minority_pct < 5) {
    warning(sprintf("Men's %s has severe class imbalance (<5%% minority class)", target))
  }
  if (ladies_minority_pct < 5) {
    warning(sprintf("Ladies %s has severe class imbalance (<5%% minority class)", target))
  }
}

# Sample TopThree values
cat("First 20 ladies Place and TopThree values:\n")
sample_topthree <- df_place_ladies %>% 
  dplyr::select(Skier, Season, Place, TopThree) %>% 
  head(20)
print(sample_topthree)
```

**Purpose**: Provides comprehensive validation of categorical outcome creation and identifies potential modeling challenges.

**Validation Framework**:
- **Cross-Tabulation Analysis**: Validates that categorical outcomes align correctly with place rankings
- **Factor Level Verification**: Ensures all categorical outcomes have expected binary levels (0, 1)
- **Class Balance Assessment**: Identifies class imbalance that could affect odds modeling quality
- **Sample Verification**: Provides concrete examples to validate categorical outcome logic

**Class Imbalance Monitoring**:
- **Severe Imbalance Detection**: Warns when minority class <5% (could cause modeling issues)
- **Cross-Gender Comparison**: Compares class balance between men's and women's alpine skiing
- **Performance Threshold Analysis**: Shows how class balance varies across different performance thresholds

#### 6. Prediction Data Preparation for Odds Calculation
```r
# Prepare 2025 prediction data with validation
cat("\n--- 2025 Prediction Data Preparation ---\n")

# Validate prediction data exists
if (!exists("men_pred_data") || is.null(men_pred_data)) {
  warning("Men's 2026 prediction data not available from previous section")
  men_pred_data <- data.frame()
}
if (!exists("ladies_pred_data") || is.null(ladies_pred_data)) {
  warning("Ladies 2026 prediction data not available from previous section") 
  ladies_pred_data <- data.frame()
}

# Men's prediction data preparation
pred_data_men <- NULL
if (nrow(men_pred_data) > 0) {
  tryCatch({
    # Define expected columns for prediction data (alpine-specific)
    expected_pred_cols <- c("Skier", "Nation", "Pelo", "Downhill_Pelo", "Super G_Pelo", 
                           "Giant Slalom_Pelo", "Slalom_Pelo", "Combined_Pelo", 
                           "Tech_Pelo", "Speed_Pelo", "Pct_of_Max_Points")
    
    available_pred_cols <- intersect(expected_pred_cols, names(men_pred_data))
    missing_pred_cols <- setdiff(expected_pred_cols, names(men_pred_data))
    
    cat(sprintf("Men's prediction columns: %d available, %d missing\n", 
                length(available_pred_cols), length(missing_pred_cols)))
    
    if (length(missing_pred_cols) > 0) {
      cat("Missing men's prediction columns:", paste(missing_pred_cols, collapse = ", "), "\n")
    }
    
    if (length(available_pred_cols) >= 4) {  # Need at least basic info
      pred_data_men <- men_pred_data[available_pred_cols]
      
      # Rename to match training data feature names (alpine-specific)
      rename_map <- c("Prev_Pelo" = "Pelo", "Prev_Downhill" = "Downhill_Pelo", 
                     "Prev_Super_G" = "Super G_Pelo", "Prev_Giant_Slalom" = "Giant Slalom_Pelo",
                     "Prev_Slalom" = "Slalom_Pelo", "Prev_Combined" = "Combined_Pelo", 
                     "Prev_Tech" = "Tech_Pelo", "Prev_Speed" = "Speed_Pelo", 
                     "Prev_Pct_of_Max_Points" = "Pct_of_Max_Points", "Nation" = "Nation")
      
      for (old_name in names(rename_map)) {
        if (rename_map[old_name] %in% names(pred_data_men)) {
          names(pred_data_men)[names(pred_data_men) == rename_map[old_name]] <- old_name
        }
      }
      
      # Handle column names with spaces by converting to underscores
      if ("Super G_Pelo" %in% names(pred_data_men)) {
        names(pred_data_men)[names(pred_data_men) == "Super G_Pelo"] <- "Prev_Super_G"
      }
      if ("Giant Slalom_Pelo" %in% names(pred_data_men)) {
        names(pred_data_men)[names(pred_data_men) == "Giant Slalom_Pelo"] <- "Prev_Giant_Slalom"
      }
      
      cat(sprintf("✓ Men's prediction data prepared: %d rows, %d columns\n", 
                  nrow(pred_data_men), ncol(pred_data_men)))
    } else {
      warning("Insufficient columns for men's prediction data preparation")
      pred_data_men <- data.frame()
    }
    
  }, error = function(e) {
    cat("Error preparing men's prediction data:", e$message, "\n")
    pred_data_men <- data.frame()
  })
} else {
  cat("No men's prediction data available\n")
  pred_data_men <- data.frame()
}
```

**Purpose**: Prepares 2026 prediction data for odds calculation by aligning feature names and validating data availability.

**Prediction Data Processing**:
- **Alpine-Specific Column Mapping**: Handles all alpine disciplines (Downhill, Super G, Giant Slalom, Slalom, Combined)
- **Feature Name Alignment**: Converts prediction data column names to match training data format
- **Space Handling**: Properly manages alpine discipline names containing spaces
- **Minimum Data Requirements**: Ensures at least 4 columns available for meaningful odds calculation

**Data Validation**:
- **Column Availability Assessment**: Reports available vs missing prediction columns
- **Graceful Degradation**: Continues processing with available columns when some are missing
- **Error Handling**: Robust error handling ensures prediction data preparation succeeds or fails gracefully

### Alpine Odds-Specific Design Considerations

#### Performance Threshold Framework
Alpine skiing odds framework uses sport-specific performance thresholds:
- **Championship Level**: Win category captures seasonal overall victory
- **Elite Consistency**: TopThree represents podium-level alpine performance
- **Competitive Tiers**: Top5, Top10, Top30 provide graduated performance levels
- **Points System Alignment**: Top30 threshold aligns with alpine World Cup points eligibility

#### Season-Based Ranking Context
Ranking system accounts for alpine skiing's competitive structure:
- **Seasonal Context**: Rankings calculated within seasons to account for varying competitive fields
- **Performance Standardization**: Uses percentage of maximum points for cross-season comparability
- **Tie-Breaking Consistency**: Standardized tie-breaking ensures reproducible rankings

#### Alpine-Specific Data Requirements
Odds framework handles alpine skiing's multi-discipline structure:
- **Discipline Coverage**: Accommodates all five alpine disciplines plus aggregate categories
- **ELO Integration**: Incorporates discipline-specific and overall ELO ratings
- **Feature Flexibility**: Handles missing disciplines gracefully while maintaining prediction capability

### Error Handling and Quality Assurance
- **Comprehensive Data Validation**: Validates training and prediction data availability and quality
- **Ranking System Verification**: Extensive validation of season-based ranking calculations
- **Categorical Outcome Validation**: Cross-tabulation and factor level verification
- **Class Balance Monitoring**: Identifies potential modeling challenges from class imbalance
- **Prediction Data Alignment**: Ensures feature name consistency between training and prediction data

This alpine odds setup section establishes a robust framework for odds calculation that respects alpine skiing's competitive structure while providing comprehensive validation and error handling to ensure reliable odds modeling across multiple performance thresholds.