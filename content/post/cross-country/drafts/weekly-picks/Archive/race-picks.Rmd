---
title: "Race Predictions"
author: "Syver Johansen"
date: "`r Sys.Date()`"
output: html_document
---

# Race Predictions with Probability and Odds

This RMarkdown document implements a prediction system for individual cross-country ski races based on the official startlist. This simplified version focuses only on predicting points and odds for a single upcoming race rather than multiple weekend races.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```
Now let's continue with the library loading and initial data setup:

```{r ingest}
# Race Predictions: Single Race Methodology
library(dplyr)
library(tidyr)
library(openxlsx)
library(arrow)
library(mgcv)
library(leaps)
library(logger)
library(purrr)
library(lubridate) # For better date handling
library(slider)    # For sliding window operations

# Define points systems
wc_points <- c(100,95,90,85,80,75,72,69,66,63,60,58,56,54,52,50,48,46,44,42,40,38,36,34,32,30,28,26,24,22,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)
stage_points <- c(50,47,44,41,38,35,32,30,28,26,24,22,20,18,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)
tds_points <- c(300,285,270,255,240,216,207,198,189,180,174,168,162,156,150,144,138,132,126,120,114,108,102,96,90,84,78,72,66,60,57,54,51,48,45,42,39,36,33,30,27,24,21,18,15,12,9,6,3)

# Function to replace NAs with first quartile value
replace_na_with_quartile <- function(x) {
  if(all(is.na(x))) return(rep(0, length(x)))
  q1 <- quantile(x, 0.25, na.rm = TRUE)
  ifelse(is.na(x), q1, x)
}

# Set up logging
log_dir <- "~/ski/elo/python/ski/polars/excel365/race-predictions"
if (!dir.exists(log_dir)) {
  dir.create(log_dir, recursive = TRUE)
}

log_threshold(DEBUG)
log_appender(appender_file(file.path(log_dir, "race_picks_processing.log")))
log_info("Starting race predictions process")

# Read in race information
log_info("Reading race data")
races <- read.csv("~/ski/elo/python/ski/polars/excel365/races.csv", stringsAsFactors = FALSE) %>%
  mutate(Date = as.Date(Date, format="%Y-%m-%d"))

# Find the next race
current_date <- Sys.Date()
log_info(paste("Current date:", current_date))

# Filter races after the current date and get the next date
next_races <- races %>%
  filter(Date > current_date) %>%
  arrange(Date)

# Check if there are any upcoming races
if(nrow(next_races) == 0) {
  stop("No upcoming races found in the races.csv file")
}

# Get the date of the next race
next_race_date <- min(next_races$Date, na.rm = TRUE)
log_info(paste("Next race date:", next_race_date))

# Filter races for just the next race day
next_day_races <- next_races %>%
  filter(Date == next_race_date)

# Create race dataframes for men and ladies
men_race <- next_day_races %>%
  filter(Sex == "M") %>%
  select(Date, City, Country, Distance, Technique, MS, Elevation, Period, Pursuit, Startlist) %>%
  rename(distance = Distance, technique = Technique, 
         ms = MS, altitude = Elevation, period = Period)

ladies_race <- next_day_races %>%
  filter(Sex == "L") %>%
  select(Date, City, Country, Distance, Technique, MS, Elevation, Period, Pursuit, Startlist) %>%
  rename(distance = Distance, technique = Technique, 
         ms = MS, altitude = Elevation, period = Period)

print(men_race)
print(ladies_race)
log_info(paste("Found", nrow(men_race), "men's race and", nrow(ladies_race), "ladies race"))
```


```{r preprocess}
get_points <- function(place, points_list) {
  if (place >= 1 && place <= length(points_list)) {
    return(points_list[place])
  }
  return(0)
}

# Function to prepare startlist data with ELO information
prepare_startlist_data <- function(startlist, race_df, pelo_col) {
    # Print some debug info
    log_info(paste("Preparing startlist data for", pelo_col))
    
    # Keep only essential columns from startlist
    base_df <- startlist %>%
        dplyr::select(Skier, ID, Nation, Price, Race_Elo)
    
    # Get all required Elo columns from the startlist
    elo_cols <- c("Elo", "Distance_Elo", "Distance_C_Elo", "Distance_F_Elo",
                  "Sprint_Elo", "Sprint_C_Elo", "Sprint_F_Elo",
                  "Freestyle_Elo", "Classic_Elo", "Race_Elo")
    
    # Add any missing Elo columns to the startlist
    for(col in elo_cols) {
        if(!(col %in% names(base_df)) && col %in% names(startlist)) {
            base_df[[col]] <- startlist[[col]]
        } else if(!(col %in% names(base_df))) {
            base_df[[col]] <- NA
        }
    }
    
    # Get recent points for specific race type
    recent_points <- race_df %>%
        filter(Skier %in% base_df$Skier) %>%
        filter(
            if(grepl("^Sprint", pelo_col)) {
                Distance == "Sprint" & 
                (Technique == substr(pelo_col, 8, 8) | substr(pelo_col, 8, 8) == "")
            } else {
                Distance != "Sprint" & 
                (Technique == substr(pelo_col, 10, 10) | substr(pelo_col, 10, 10) == "")
            }
        ) %>%
        group_by(Skier) %>%
        arrange(Season, Race) %>%
        slice_tail(n = 5) %>%
        summarise(
            Prev_Points_Weighted = if(n() > 0) 
                weighted.mean(Points, w = seq_len(n()), na.rm = TRUE) 
                else 0
        )

    # Combine startlist with recent points
    result_df <- base_df %>%
        left_join(recent_points, by = "Skier")
    
    # Calculate Pelo_Pct values for each Elo type
    for(elo_col in elo_cols) {
        pelo_pct_col <- paste0(elo_col, "_Pct")
        
        # Only calculate if the column exists and has non-NA values
        if(elo_col %in% names(result_df) && !all(is.na(result_df[[elo_col]]))) {
            # Calculate the maximum value for normalization
            max_val <- max(result_df[[elo_col]], na.rm = TRUE)
            
            # Only calculate if max value is positive
            if(!is.na(max_val) && max_val > 0) {
                result_df[[pelo_pct_col]] <- result_df[[elo_col]] / max_val
            } else {
                result_df[[pelo_pct_col]] <- 0.5  # Default value
            }
        } else {
            # Create a default value if column is missing
            result_df[[pelo_pct_col]] <- 0.5
        }
    }
    
    # Replace NAs with first quartile
    result_df <- result_df %>%
        mutate(
            across(
                ends_with("_Pct"),
                ~replace_na_with_quartile(.x)
            ),
            Prev_Points_Weighted = replace_na(Prev_Points_Weighted, 0)
        )
    
    return(result_df)
}

# Function to preprocess race data
preprocess_data <- function(df) {
    # First calculate points using ALL historical data
    df_with_points <- df %>%
        # Add points
        mutate(Points = map_int(Place, ~ get_points(.x, wc_points))) %>%
        # Sort
        arrange(Season, Race, Place)
    
    # Calculate weighted previous points separately for each race type/technique combination
    df_with_points <- df_with_points %>%
        # Group by ID and race type
        group_by(ID, Distance, Technique) %>%
        arrange(Season, Race) %>%
        mutate(Prev_Points_Weighted = sapply(1:n(), function(j) {
            if (j == 1) return(0)
            start_index <- max(1, j - 5)
            num_races <- j - start_index
            weights <- seq(1, num_races)
            weighted.mean(Points[start_index:(j-1)], w = weights, na.rm = TRUE)
        })) %>%
        ungroup()
    
    # Make sure Pelo columns exist
    pelo_cols <- c("Distance_Pelo", "Distance_C_Pelo", "Distance_F_Pelo",
                   "Pelo", "Sprint_Pelo", "Sprint_C_Pelo", "Sprint_F_Pelo",
                   "Freestyle_Pelo", "Classic_Pelo")
    
    # Create missing columns
    for (col in pelo_cols) {
      if (!col %in% names(df_with_points)) {
        log_info(paste("Creating missing column:", col))
        df_with_points[[col]] <- 0
      }
    }
    
    # Apply other preprocessing steps
    processed_df <- df_with_points %>%
        # Add period
        group_by(Season) %>%
        mutate(
            Num_Races = max(Race),
            Period = case_when(
                Num_Races <= 5 ~ 1,
                Num_Races <= 10 ~ 2,
                Num_Races <= 15 ~ 3,
                Num_Races <= 20 ~ 4,
                Num_Races <= 25 ~ 5,
                TRUE ~ ceiling((Race / (Num_Races / 5)))
            )
        ) %>%
        ungroup() %>%
        # Filter relevant races and add cumulative points
        filter(
            Season > 2014,
            Event %in% c("World Cup", "Nordic Opening", "Tour de Ski", 
                        "Olympic Winter Games", "World Championship", 
                        "World Cup Final", "Ski Tour Canada")
        ) %>%
        group_by(ID, Season) %>%
        mutate(Cumulative_Points = cumsum(Points)) %>%
        ungroup() %>%
        # Handle NAs and calculate percentages
        group_by(Season, Race) %>%
        mutate(
            across(
                all_of(pelo_cols),
                ~replace_na_with_quartile(.x)
            )
        ) %>%
        # Calculate percentages for each Pelo column
        mutate(
            across(
                all_of(pelo_cols),
                ~{
                    max_val <- max(.x, na.rm = TRUE)
                    if (max_val == 0) return(rep(0, length(.x)))
                    .x / max_val
                },
                .names = "{.col}_Pct"
            )
        ) %>%
        ungroup() %>%
        # Filter out team sprint and relay
        filter(!Distance %in% c("Ts", "Rel"))
    
    # Ensure all required Pelo_Pct columns exist
    pct_cols <- paste0(pelo_cols, "_Pct")
    for (col in pct_cols) {
      if (!col %in% names(processed_df)) {
        log_info(paste("Creating missing percentage column:", col))
        processed_df[[col]] <- 0
      }
    }
    
    return(processed_df)
}
```

```{r predict_race}
# Function to predict a single race
predict_race <- function(gender) {
  # Load chronological data
  chrono_path <- ifelse(gender == "men", 
                    "~/ski/elo/python/ski/polars/excel365/men_chrono_elevation.csv",
                    "~/ski/elo/python/ski/polars/excel365/ladies_chrono_elevation.csv")
  
  # Get the appropriate race and startlist filename
  race <- if(gender == "men") men_race else ladies_race
  
  # Exit if there's no race for this gender
  if(nrow(race) == 0) {
    log_info(paste("No", gender, "race found for prediction"))
    return(NULL)
  }
  
  # Get the startlist filename from the race data
  startlist_file <- race$Startlist[1]
  if(is.na(startlist_file) || startlist_file == "") {
    log_info(paste("No startlist file specified for", gender, "race"))
    return(NULL)
  }
  
  log_info(paste("Processing", gender, "race with startlist:", startlist_file))
  
  # Read chronological data
  df <- read.csv(chrono_path, stringsAsFactors = FALSE) %>%
    mutate(Date = as.Date(Date)) %>%
    preprocess_data()
  
  # Read startlist
  startlist <- read.csv(startlist_file, stringsAsFactors = FALSE)
  
  # Check if startlist has the required columns
  required_cols <- c("Skier", "ID", "Nation")
  missing_cols <- required_cols[!required_cols %in% names(startlist)]
  if(length(missing_cols) > 0) {
    log_error(paste("Startlist missing required columns:", paste(missing_cols, collapse=", ")))
    return(NULL)
  }
  
  log_info(paste("Startlist loaded with", nrow(startlist), "competitors"))
  
  # Filter base dataset for race type
  race_df <- df %>%
    {if(race$distance[1] == "Sprint") {
      if(race$technique[1] == "") {
        filter(., Distance == "Sprint")  # Don't filter by technique if it's empty
      } else {
        filter(., Distance == "Sprint", Technique == race$technique[1])
      }
    } else {
      if(race$technique[1] == "") {
        filter(., Distance != "Sprint")  # Don't filter by technique if it's empty
      } else {
        filter(., Distance != "Sprint", Technique == race$technique[1])
      }
    }}
  
  # Add altitude categories for historical data
  race_df <- race_df %>%
    mutate(
      AltitudeCategory = ifelse(Elevation >= 1300, 1, 0)
    )
  
  # Get relevant Pelo column
  pelo_col <- case_when(
    race$distance[1] == "Sprint" & race$technique[1] == "C" ~ "Sprint_C_Pelo_Pct",
    race$distance[1] == "Sprint" & race$technique[1] == "F" ~ "Sprint_F_Pelo_Pct",
    race$distance[1] == "Distance" & race$technique[1] == "C" ~ "Distance_C_Pelo_Pct",
    race$distance[1] == "Distance" & race$technique[1] == "F" ~ "Distance_F_Pelo_Pct",
    race$distance[1] == "Distance" & race$technique[1] == "" ~ "Distance_Pelo_Pct",
    race$distance[1] == "Sprint" & race$technique[1] == "" ~ "Sprint_Pelo_Pct",
    TRUE ~ "Pelo_Pct"
  )
  
  # Filter for top performers and add previous points
  race_df_75 <- race_df %>%
    filter(get(pelo_col) > 0.75) %>%
    group_by(ID) %>%
    arrange(Season, Race) %>%
    ungroup()

  # Feature selection and model fitting
  response_variable <- "Points"
  explanatory_vars <- c("Prev_Points_Weighted", "Distance_Pelo_Pct", "Sprint_Pelo_Pct", 
                      "Sprint_C_Pelo_Pct", "Distance_F_Pelo_Pct", "Distance_C_Pelo_Pct", 
                      "Classic_Pelo_Pct", "Freestyle_Pelo_Pct", "Sprint_F_Pelo_Pct", "Pelo_Pct")
  
  # Create and fit model
  formula <- as.formula(paste(response_variable, "~", paste(explanatory_vars, collapse = " + ")))
  exhaustive_selection <- regsubsets(formula, data = race_df_75, nbest = 1, method = "exhaustive")
  summary_exhaustive <- summary(exhaustive_selection)
  best_bic_vars <- names(coef(exhaustive_selection, which.min(summary_exhaustive$bic)))
  smooth_terms <- paste("s(", best_bic_vars[-1], ")", collapse=" + ")
  gam_formula <- as.formula(paste("Points ~", smooth_terms))
  
  model <- gam(gam_formula, data = race_df_75)
  
  # Calculate adjustments for historical data step by step
  race_df_75 <- race_df_75 %>%
    arrange(Date) %>%
    group_by(Skier) %>%
    mutate(
      row_id = row_number()
    ) %>%
    ungroup() %>%
    # Step 1: Initial predictions
    mutate(
      Initial_Prediction = predict(model, newdata = .)
    ) %>%
    group_by(Skier) %>%
    mutate(
      Prediction_Diff = Points - Initial_Prediction
    ) %>%
    # Step 2: Calculate altitude p-values and effects
    mutate(
      altitude_p = purrr::map_dbl(row_id, function(r) {
        if(r <= 1) return(1)
        prior_alt_1 <- Prediction_Diff[AltitudeCategory == 1 & row_id < r]
        prior_alt_0 <- Prediction_Diff[AltitudeCategory == 0 & row_id < r]
        if(length(prior_alt_1) < 3 || length(prior_alt_0) < 3) return(1)
        tryCatch({
          t.test(prior_alt_1, prior_alt_0)$p.value
        }, error = function(e) 1)
      }),
      altitude_correction = ifelse(altitude_p < 0.05 & AltitudeCategory == 1,
                                 mean(Prediction_Diff[AltitudeCategory == 1], na.rm = TRUE),
                                 0)
    ) %>%
    # Step 3: Calculate course-adjusted predictions
    mutate(
      Course_Adjusted = Initial_Prediction + altitude_correction,
      Course_Diff = Points - Course_Adjusted
    ) %>%
    # Step 4: Calculate Period adjustments
    mutate(
      period_p = purrr::map_dbl(row_id, function(r) {
        if(r <= 1) return(1)
        prior_period_curr <- Course_Diff[Period == Period[r] & row_id < r]
        prior_period_other <- Course_Diff[Period != Period[r] & row_id < r]
        if(length(prior_period_curr) < 3 || length(prior_period_other) < 3) return(1)
        tryCatch({
          t.test(prior_period_curr, prior_period_other)$p.value
        }, error = function(e) 1)
      }),
      period_correction = ifelse(period_p < 0.05,
                              mean(Course_Diff[Period == Period], na.rm = TRUE),
                              0),
      Period_Adjusted = Course_Adjusted + period_correction,
      Period_Diff = Points - Period_Adjusted
    ) %>%
    # Step 5: Calculate Mass Start adjustments
    mutate(
      ms_p = purrr::map_dbl(row_id, function(r) {
        if(r <= 1) return(1)
        prior_ms_curr <- Period_Diff[MS == MS[r] & row_id < r]
        prior_ms_other <- Period_Diff[MS != MS[r] & row_id < r]
        if(length(prior_ms_curr) < 3 || length(prior_ms_other) < 3) return(1)
        tryCatch({
          t.test(prior_ms_curr, prior_ms_other)$p.value
        }, error = function(e) 1)
      }),
      ms_correction = ifelse(ms_p < 0.05,
                          mean(Period_Diff[MS == MS], na.rm = TRUE),
                          0)
    ) %>%
    ungroup()
  
  # Calculate volatility metrics using recent races
  race_df_75 <- race_df_75 %>%
    group_by(Skier) %>%
    arrange(Date) %>%  # Ensure chronological order
    mutate(
      # Create rolling window calculations for last 10 races
      recent_prediction_volatility = slider::slide_dbl(
        Points - Initial_Prediction,
        sd,
        .before = 9,  # Look at current race plus 9 previous
        .complete = FALSE  # Allow partial windows
      ),
      
      recent_consistency_score = slider::slide_dbl(
        abs(Points - Initial_Prediction),
        mean,
        .before = 9,
        .complete = FALSE
      ),
      
      recent_upside_potential = slider::slide_dbl(
        Points - Initial_Prediction,
        ~quantile(.x, 0.9, na.rm = TRUE),
        .before = 9,
        .complete = FALSE
      ),
      
      recent_downside_risk = slider::slide_dbl(
        Points - Initial_Prediction,
        ~quantile(.x, 0.1, na.rm = TRUE),
        .before = 9,
        .complete = FALSE
      )
    ) %>%
    mutate(
      recent_volatility_ratio = recent_upside_potential / abs(recent_downside_risk)
    ) %>%
    ungroup()
  
  # Get final adjustments for each skier
  skier_adjustments <- race_df_75 %>%
    group_by(Skier) %>%
    summarise(
      altitude_effect = last(altitude_correction),
      period_effect = last(period_correction),
      ms_effect = last(ms_correction),
      
      # Recent volatility metrics
      prediction_volatility = last(recent_prediction_volatility),
      consistency_score = last(recent_consistency_score),
      upside_potential = last(recent_upside_potential),
      downside_risk = last(recent_downside_risk),
      volatility_ratio = last(recent_volatility_ratio),
      
      # Add number of recent races for confidence
      n_recent_races = sum(!is.na(tail(Points, 10)))
    )

  # Prepare startlist for predictions
  startlist_prepared <- prepare_startlist_data(startlist, race_df, pelo_col)
  
  # Make predictions
  race_predictions <- startlist_prepared %>%
    mutate(
      Base_Prediction = predict(model, newdata = .),
    ) %>%
    left_join(skier_adjustments, by = "Skier") %>%
    mutate(
      # Regular adjustments
      altitude_effect = replace_na(altitude_effect, 0),
      period_effect = replace_na(period_effect, 0),
      ms_effect = replace_na(ms_effect, 0),
      
      # Volatility metrics
      prediction_volatility = replace_na(prediction_volatility, 0),
      consistency_score = replace_na(consistency_score, 0),
      upside_potential = replace_na(upside_potential, 0),
      downside_risk = replace_na(downside_risk, 0),
      volatility_ratio = replace_na(volatility_ratio, 1),
      n_recent_races = replace_na(n_recent_races, 0),
      
      # Regular adjustments
      altitude_adjustment = altitude_effect,
      period_adjustment = period_effect,
      ms_adjustment = ms_effect,
      
      # Final prediction and adjustments
      Final_Prediction = Base_Prediction + altitude_adjustment + 
                      period_adjustment + ms_adjustment,
      Final_Prediction = pmax(pmin(Final_Prediction, 100), 0),
      
      # Different scoring scenarios
      confidence_factor = pmin(n_recent_races / 10, 1),
      scaled_upside_potential = upside_potential * (Final_Prediction/100),
      scaled_downside_potential = downside_risk * (Final_Prediction/100),
      
      # Safe prediction (downside)
      Safe_Prediction = pmax(
        Final_Prediction - (prediction_volatility * 1.5 * confidence_factor), 
        0
      ),
      
      # Upside prediction
      Upside_Prediction = pmin(
        Final_Prediction + (prediction_volatility * 1.5 * confidence_factor), 
        100  # Cap at 100
      )
    ) %>%
    select(Skier, Nation, ID, 
           Base_Prediction, altitude_adjustment, 
           period_adjustment, ms_adjustment,
           prediction_volatility, volatility_ratio, confidence_factor,
           Final_Prediction, Safe_Prediction, Upside_Prediction)
  
  # Apply pursuit handling if needed
  if(race$Pursuit[1] == 1) {
    # Get startlist positions (assume they're already in order)
    startlist_points <- startlist %>%
      mutate(
        startlist_points = case_when(
          row_number() <= length(stage_points) ~ stage_points[row_number()],
          TRUE ~ 0
        )
      ) %>%
      select(Skier, startlist_points)
    
    # Apply pursuit logic - average predicted points with startlist points
    race_predictions <- race_predictions %>%
      left_join(startlist_points, by = "Skier") %>%
      mutate(
        startlist_points = replace_na(startlist_points, 0),
        Final_Prediction = (Final_Prediction + startlist_points) / 2,
        Safe_Prediction = (Safe_Prediction + startlist_points) / 2,
        Upside_Prediction = (Upside_Prediction + startlist_points) / 2
      ) %>%
      select(-startlist_points)
    
    log_info("Applied pursuit logic to race predictions")
  }
  
  log_info(paste("Predictions completed for", gender, "race with", nrow(race_predictions), "competitors"))
  
  # Create folder path based on race date
  race_folder <- format(race$Date[1], "%Y%m%d")
  city_name <- gsub("[^a-zA-Z0-9]", "", race$City[1])  # Clean city name for filename
  dir_path <- paste0("~/ski/elo/python/ski/polars/excel365/race-predictions/", race_folder)
  
  # Create directory if it doesn't exist
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }
  
  # Save predictions to Excel
  file_path <- file.path(dir_path, paste0(gender, "_", city_name, "_predictions.xlsx"))
  write.xlsx(race_predictions %>% arrange(desc(Final_Prediction)), file = file_path)
  
  log_info(paste("Saved", gender, "predictions to", file_path))
  
  return(race_predictions)
}
```


```{r position_probabilities}
# Position probability prediction for races
position_thresholds <- c(1, 3, 10, 30)  # Win, Podium, Top 10, Top 30

create_position_model <- function(data, threshold, selected_vars) {
  # Create binary outcome
  data$position_achieved <- data$Place <= threshold
  
  # Create formula for GAM
  formula_str <- paste("position_achieved ~",
                      paste(paste0("s(", selected_vars, ")"),
                      collapse = " + "))
  
  # Fit GAM model
  model <- gam(as.formula(formula_str),
               data = data,
               family = binomial,
               method = "REML")
  
  return(model)
}

# Function to select features for prediction
select_features <- function(data, threshold, max_vars = 5) {
  # Create binary outcome
  data$position_achieved <- data$Place <= threshold
  
  # Check if we have enough variability
  if (sum(data$position_achieved) < 10 || sum(!data$position_achieved) < 10) {
    log_info(paste("Not enough variability for threshold", threshold, "- skipping"))
    return(NULL)
  }
  
  # Get predictor columns (excluding non-predictors)
  pred_cols <- c("Elo", "Distance_Elo", "Distance_C_Elo", "Distance_F_Elo", 
                "Sprint_Elo", "Sprint_C_Elo", "Sprint_F_Elo", 
                "Classic_Elo", "Freestyle_Elo", "Prev_Points_Weighted")
  
  # Check all columns for sufficient variability
  valid_cols <- character(0)
  for (col in pred_cols) {
    if (col %in% names(data) && is.numeric(data[[col]]) && 
        !all(is.na(data[[col]])) && length(unique(na.omit(data[[col]]))) > 5) {
      valid_cols <- c(valid_cols, col)
    }
  }
  
  # If no valid predictors, return NULL
  if (length(valid_cols) == 0) {
    log_info("No valid predictors with sufficient variability found")
    return(NULL)
  }
  
  # Create formula for regsubsets
  formula_str <- paste("position_achieved ~", paste(valid_cols, collapse = " + "))
  
  tryCatch({
    subset_search <- regsubsets(as.formula(formula_str),
                              data = data,
                              nvmax = min(max_vars, length(valid_cols)),
                              method = "forward",
                              really.big = TRUE)
    return(subset_search)
  },
  error = function(e) {
      log_info(paste("Error in feature selection:", e$message))
      return(NULL)
    })
}

# Create models for race type
create_position_models <- function(filtered_df, thresholds = position_thresholds, max_vars = 5) {
  models <- list()
  selected_features <- list()
  
  for(threshold in thresholds) {
    log_info(paste("Creating model for top", threshold, "positions"))
    
    # Feature selection
    features <- select_features(filtered_df, threshold, max_vars)
    
    # Check if feature selection was successful
    if (is.null(features)) {
      log_info(paste("Skipping model for threshold", threshold, "due to insufficient data"))
      next
    }
    
    best_model_idx <- which.min(summary(features)$bic)
    selected_vars <- names(coef(features, best_model_idx))[-1]  # Remove intercept
    
    # If no features were selected, skip this threshold
    if (length(selected_vars) == 0) {
      log_info(paste("No features selected for threshold", threshold))
      next
    }
    
    log_info(paste("Selected variables:", paste(selected_vars, collapse=", ")))
    
    # Create and store model
    tryCatch({
      model <- create_position_model(filtered_df, threshold, selected_vars)
      models[[paste0("place_", threshold)]] <- model
      selected_features[[paste0("place_", threshold)]] <- selected_vars
    }, error = function(e) {
      log_info(paste("Error creating model for threshold", threshold, ":", e$message))
    })
  }
  
  # If no models were created, return NULL
  if (length(models) == 0) {
    log_info("No models could be created - insufficient data")
    return(NULL)
  }
  
  return(list(models = models, selected_features = selected_features))
}

# Function to predict position probabilities
predict_positions <- function(startlist_prepared, models) {
  # If no models were created, return just Skier and Nation
  if (is.null(models)) {
    return(data.frame(
      Skier = startlist_prepared$Skier,
      Nation = startlist_prepared$Nation
    ))
  }
  
  predictions <- data.frame(
    Skier = startlist_prepared$Skier,
    Nation = startlist_prepared$Nation
  )
  
  for(threshold in position_thresholds) {
    model_name <- paste0("place_", threshold)
    
    # Check if this model exists
    if (!model_name %in% names(models$models)) {
      # If model doesn't exist, set all probabilities to NA
      predictions[[paste0("prob_top", threshold)]] <- NA
      next
    }
    
    model <- models$models[[model_name]]
    
    # Ensure all required variables exist
    required_vars <- attr(terms(model), "term.labels")
    required_vars <- gsub("^s\\((.+)\\)$", "\\1", required_vars)
    
    for(var in required_vars) {
      if(!var %in% names(startlist_prepared)) {
        log_info(paste("Adding missing variable:", var))
        startlist_prepared[[var]] <- 0
      }
    }
    
    # Get predictions
    tryCatch({
      pred_probs <- predict(model, newdata = startlist_prepared, type = "response")
      predictions[[paste0("prob_top", threshold)]] <- pred_probs
    }, error = function(e) {
      log_info(paste("Error predicting for threshold", threshold, ":", e$message))
      predictions[[paste0("prob_top", threshold)]] <- NA
    })
  }
  
  # Format probabilities as percentages for readability
  predictions <- predictions %>%
    mutate(across(starts_with("prob_top"), ~ round(.x * 100, 1)))
  
  return(predictions)
}

# Function to calculate implied odds from probabilities
convert_to_odds <- function(prob) {
  # Ensure probability is between 0.01 and 0.99 to avoid extreme odds
  prob <- pmax(pmin(prob/100, 0.99), 0.01)
  # Convert to decimal odds (1/probability)
  odds <- 1 / prob
  # Round to one decimal place
  return(round(odds, 1))
}

run_position_predictions <- function(race_predictions, gender, race) {
  log_info("Running position probability predictions")
  
  # Load chronological data
  chrono_path <- ifelse(gender == "men", 
                      "~/ski/elo/python/ski/polars/excel365/men_chrono_elevation.csv",
                      "~/ski/elo/python/ski/polars/excel365/ladies_chrono_elevation.csv")
  
  chrono_df <- read.csv(chrono_path, stringsAsFactors = FALSE) %>%
    preprocess_data()
  
  # Filter historical data for this race type
  race_df <- chrono_df %>%
    {if(race$distance[1] == "Sprint") {
      if(race$technique[1] == "") {
        filter(., Distance == "Sprint")
      } else {
        filter(., Distance == "Sprint", Technique == race$technique[1])
      }
    } else {
      if(race$technique[1] == "") {
        filter(., Distance != "Sprint")
      } else {
        filter(., Distance != "Sprint", Technique == race$technique[1])
      }
    }}
  
  # Create position models for this race type
  position_models <- create_position_models(race_df)
  
  # Prepare startlist data (reusing the already predicted dataframe)
  startlist_prepared <- race_predictions %>%
    select(Skier, Nation, ID)
  
  # Add any missing columns needed for the position probability model
  pelo_col <- case_when(
    race$distance[1] == "Sprint" & race$technique[1] == "C" ~ "Sprint_C_Pelo_Pct",
    race$distance[1] == "Sprint" & race$technique[1] == "F" ~ "Sprint_F_Pelo_Pct",
    race$distance[1] == "Distance" & race$technique[1] == "C" ~ "Distance_C_Pelo_Pct",
    race$distance[1] == "Distance" & race$technique[1] == "F" ~ "Distance_F_Pelo_Pct",
    race$distance[1] == "Distance" & race$technique[1] == "" ~ "Distance_Pelo_Pct",
    race$distance[1] == "Sprint" & race$technique[1] == "" ~ "Sprint_Pelo_Pct",
    TRUE ~ "Pelo_Pct"
  )
  
  # Get the startlist file to read in the Elo scores
  startlist_file <- race$Startlist[1]
  if(!is.na(startlist_file) && startlist_file != "") {
    startlist <- read.csv(startlist_file, stringsAsFactors = FALSE)
    startlist_prepared <- prepare_startlist_data(startlist, race_df, pelo_col)
  }
  
  # Get position probability predictions
  position_preds <- predict_positions(startlist_prepared, position_models)
  
  # Combine with points predictions
  combined_predictions <- race_predictions %>%
    select(Skier, Nation, Final_Prediction, Safe_Prediction, Upside_Prediction) %>%
    left_join(position_preds, by = c("Skier", "Nation"))
  
  # Add odds columns
  odds_predictions <- combined_predictions %>%
    mutate(
      Win_Odds = convert_to_odds(prob_top1),
      Podium_Odds = convert_to_odds(prob_top3),
      Top10_Odds = convert_to_odds(prob_top10)
    ) %>%
    rename(
      Win_Prob = prob_top1,
      Podium_Prob = prob_top3,
      Top10_Prob = prob_top10,
      Top30_Prob = prob_top30,
      Points = Final_Prediction
    )
  
  # Create folder path based on race date
  race_folder <- format(race$Date[1], "%Y%m%d")
  city_name <- gsub("[^a-zA-Z0-9]", "", race$City[1])  # Clean city name for filename
  dir_path <- paste0("~/ski/elo/python/ski/polars/excel365/race-predictions/", race_folder)
  
  # Create directory if it doesn't exist
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }
  
  # Save combined predictions to Excel
  file_path <- file.path(dir_path, paste0(gender, "_", city_name, "_odds.xlsx"))
  write.xlsx(odds_predictions %>% arrange(desc(Win_Prob)), file = file_path)
  
  log_info(paste("Saved", gender, "position probabilities to", file_path))
  
  return(odds_predictions)
}
```

```{r run_predictions}
# Execute predictions for men and ladies races
log_info("Starting race predictions")

# Run men's predictions if there's a men's race
men_predictions <- NULL
if(nrow(men_race) > 0) {
  log_info("Running men's race predictions")
  men_predictions <- predict_race("men")
  
  if(!is.null(men_predictions)) {
    # Run position probability predictions
    men_position_probs <- run_position_predictions(men_predictions, "men", men_race)
    
    # Display top 10 men's predictions
    cat("\nTop 10 Men's Predictions:\n")
    print(men_predictions %>% 
          arrange(desc(Final_Prediction)) %>% 
          select(Skier, Nation, Final_Prediction, Safe_Prediction, Upside_Prediction) %>%
          head(10))
    
    # Display top win probabilities
    cat("\nTop 5 Men's Win Probabilities:\n")
    print(men_position_probs %>% 
          arrange(desc(Win_Prob)) %>% 
          select(Skier, Nation, Win_Prob, Win_Odds, Points) %>%
          head(5))
  }
}

# Run ladies' predictions if there's a ladies' race
ladies_predictions <- NULL
if(nrow(ladies_race) > 0) {
  log_info("Running ladies' race predictions")
  ladies_predictions <- predict_race("ladies")
  
  if(!is.null(ladies_predictions)) {
    # Run position probability predictions
    ladies_position_probs <- run_position_predictions(ladies_predictions, "ladies", ladies_race)
    
    # Display top 10 ladies' predictions
    cat("\nTop 10 Ladies' Predictions:\n")
    print(ladies_predictions %>% 
          arrange(desc(Final_Prediction)) %>% 
          select(Skier, Nation, Final_Prediction, Safe_Prediction, Upside_Prediction) %>%
          head(10))
    
    # Display top win probabilities
    cat("\nTop 5 Ladies' Win Probabilities:\n")
    print(ladies_position_probs %>% 
          arrange(desc(Win_Prob)) %>% 
          select(Skier, Nation, Win_Prob, Win_Odds, Points) %>%
          head(5))
  }
}

log_info("Race predictions process complete")
```


```{r create_summary}
# Function to create a summary for the blog post
create_race_summary <- function() {
  # Create folder path based on race date
  race_date <- if(nrow(men_race) > 0) men_race$Date[1] else ladies_race$Date[1]
  race_folder <- format(race_date, "%Y%m%d")
  dir_path <- paste0("~/blog/daehl-e/content/post/cross-country/drafts/race-picks/", race_folder)
  
  # Create directory if it doesn't exist
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }
  
  # Prepare summary for men's race
  if(!is.null(men_predictions)) {
    # Get top 20 for points predictions
    men_points_summary <- men_predictions %>%
      arrange(desc(Final_Prediction)) %>%
      select(Skier, Nation, Final_Prediction) %>%
      rename(Points = Final_Prediction) %>%
      head(20)
    
    # Get top winning probabilities 
    men_win_summary <- run_position_predictions(men_predictions, "men", men_race) %>%
      arrange(desc(Win_Prob)) %>%
      select(Skier, Nation, Win_Prob, Win_Odds) %>%
      head(10)
    
    # Save separate Excel files
    write.xlsx(men_points_summary, file.path(dir_path, "men_points.xlsx"))
    write.xlsx(men_win_summary, file.path(dir_path, "men_odds.xlsx"))
    
    # Create a combined summary for a Markdown table
    men_top10 <- men_points_summary %>% head(10)
    men_markdown <- paste("## Men's Race Predictions\n\n",
                         "### Predicted Points\n\n",
                         "| Rank | Skier | Nation | Points |\n",
                         "|------|-------|--------|--------|\n",
                         paste0("| ", 1:nrow(men_top10), " | ", men_top10$Skier, 
                                " | ", men_top10$Nation, " | ", 
                                round(men_top10$Points, 1), " |\n", collapse = ""),
                         "\n\n### Win Probability\n\n",
                         "| Rank | Skier | Nation | Win % | Odds |\n",
                         "|------|-------|--------|-------|------|\n",
                         paste0("| ", 1:nrow(men_win_summary), " | ", men_win_summary$Skier, 
                                " | ", men_win_summary$Nation, " | ", 
                                men_win_summary$Win_Prob, "% | ", 
                                men_win_summary$Win_Odds, " |\n", collapse = ""),
                         "\n")
    
    # Save markdown file
    writeLines(men_markdown, file.path(dir_path, "men_summary.md"))
  }
  
  # Prepare summary for ladies' race
  if(!is.null(ladies_predictions)) {
    # Get top 20 for points predictions
    ladies_points_summary <- ladies_predictions %>%
      arrange(desc(Final_Prediction)) %>%
      select(Skier, Nation, Final_Prediction) %>%
      rename(Points = Final_Prediction) %>%
      head(20)
    
    # Get top winning probabilities 
    ladies_win_summary <- run_position_predictions(ladies_predictions, "ladies", ladies_race) %>%
      arrange(desc(Win_Prob)) %>%
      select(Skier, Nation, Win_Prob, Win_Odds) %>%
      head(10)
    
    # Save separate Excel files
    write.xlsx(ladies_points_summary, file.path(dir_path, "ladies_points.xlsx"))
    write.xlsx(ladies_win_summary, file.path(dir_path, "ladies_odds.xlsx"))
    
    # Create a combined summary for a Markdown table
    ladies_top10 <- ladies_points_summary %>% head(10)
    ladies_markdown <- paste("## Ladies' Race Predictions\n\n",
                            "### Predicted Points\n\n",
                            "| Rank | Skier | Nation | Points |\n",
                            "|------|-------|--------|--------|\n",
                            paste0("| ", 1:nrow(ladies_top10), " | ", ladies_top10$Skier, 
                                   " | ", ladies_top10$Nation, " | ", 
                                   round(ladies_top10$Points, 1), " |\n", collapse = ""),
                            "\n\n### Win Probability\n\n",
                            "| Rank | Skier | Nation | Win % | Odds |\n",
                            "|------|-------|--------|-------|------|\n",
                            paste0("| ", 1:nrow(ladies_win_summary), " | ", ladies_win_summary$Skier, 
                                   " | ", ladies_win_summary$Nation, " | ", 
                                   ladies_win_summary$Win_Prob, "% | ", 
                                   ladies_win_summary$Win_Odds, " |\n", collapse = ""),
                            "\n")
    
    # Save markdown file
    writeLines(ladies_markdown, file.path(dir_path, "ladies_summary.md"))
  }
  
  # Create combined race summary
  race_details <- paste0("# Race Predictions: ", format(race_date, "%B %d, %Y"), "\n\n",
                        "**Location:** ", ifelse(nrow(men_race) > 0, 
                                               paste0(men_race$City[1], ", ", men_race$Country[1]),
                                               paste0(ladies_race$City[1], ", ", ladies_race$Country[1])), "\n\n",
                        "**Race Type:** ", ifelse(nrow(men_race) > 0, 
                                                paste0(men_race$distance[1], " ", men_race$technique[1]),
                                                paste0(ladies_race$distance[1], " ", ladies_race$technique[1])), "\n\n",
                        "These predictions are generated using machine learning models trained on historical World Cup performance data. The model takes into account:",
                        "\n\n- Each skier's Elo rating for the specific race discipline",
                        "\n- Recent performance trends",
                        "\n- Race characteristics (altitude, period in season, mass start vs. interval start)",
                        "\n- Historical volatility and consistency\n\n")
  
  # Combine with gender-specific predictions if available
  full_summary <- race_details
  
  if(!is.null(men_predictions)) {
    men_summary <- readLines(file.path(dir_path, "men_summary.md"))
    full_summary <- paste0(full_summary, paste(men_summary, collapse = "\n"), "\n\n")
  }
  
  if(!is.null(ladies_predictions)) {
    ladies_summary <- readLines(file.path(dir_path, "ladies_summary.md"))
    full_summary <- paste0(full_summary, paste(ladies_summary, collapse = "\n"), "\n\n")
  }
  
  # Add methodology note
  methodology <- paste0("## Methodology\n\n",
                      "The predictions use a combination of:",
                      "\n\n- GAM (Generalized Additive Models) for points predictions",
                      "\n- Specialized models for position probabilities",
                      "\n- Adjustments for course-specific factors",
                      "\n\nThe model is trained on World Cup, Olympic, and World Championship data since 2015.",
                      "\n\nLast updated: ", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "\n")
  
  full_summary <- paste0(full_summary, methodology)
  
  # Save complete summary markdown
  writeLines(full_summary, file.path(dir_path, "race_predictions.md"))
  
  log_info("Created race summary files for publishing")
  
  return(dir_path)
}

# Generate the summary
summary_path <- create_race_summary()
cat("\nRace prediction summary created at:", summary_path, "\n")
```

```{r display_results}
# Display overall results summary
cat("\n=============================================================\n")
cat("           RACE PREDICTIONS SUMMARY REPORT                   \n")
cat("=============================================================\n\n")

race_date <- if(nrow(men_race) > 0) men_race$Date[1] else ladies_race$Date[1]
race_location <- if(nrow(men_race) > 0) 
  paste0(men_race$City[1], ", ", men_race$Country[1]) else 
  paste0(ladies_race$City[1], ", ", ladies_race$Country[1])

cat("Race Date:", format(race_date, "%B %d, %Y"), "\n")
cat("Location:", race_location, "\n\n")

if(nrow(men_race) > 0) {
  cat("Men's Race Type:", men_race$distance[1], men_race$technique[1], "\n")
  cat("Men's Race Characteristics:", 
      ifelse(men_race$ms[1] == 1, "Mass Start", "Interval Start"), ", ",
      ifelse(men_race$altitude[1] >= 1300, "High Altitude", "Normal Altitude"), "\n")
  if(!is.null(men_predictions)) {
    cat("Men's Top 3 Predicted Finishers:\n")
    top3_men <- men_predictions %>% 
      arrange(desc(Final_Prediction)) %>% 
      select(Skier, Nation, Final_Prediction) %>%
      head(3)
    for(i in 1:3) {
      cat(i, ". ", top3_men$Skier[i], " (", top3_men$Nation[i], ") - ", 
          round(top3_men$Final_Prediction[i], 1), " points\n", sep="")
    }
  }
  cat("\n")
}

if(nrow(ladies_race) > 0) {
  cat("Ladies' Race Type:", ladies_race$distance[1], ladies_race$technique[1], "\n")
  cat("Ladies' Race Characteristics:", 
      ifelse(ladies_race$ms[1] == 1, "Mass Start", "Interval Start"), ", ",
      ifelse(ladies_race$altitude[1] >= 1300, "High Altitude", "Normal Altitude"), "\n")
  if(!is.null(ladies_predictions)) {
    cat("Ladies' Top 3 Predicted Finishers:\n")
    top3_ladies <- ladies_predictions %>% 
      arrange(desc(Final_Prediction)) %>% 
      select(Skier, Nation, Final_Prediction) %>%
      head(3)
    for(i in 1:3) {
      cat(i, ". ", top3_ladies$Skier[i], " (", top3_ladies$Nation[i], ") - ", 
          round(top3_ladies$Final_Prediction[i], 1), " points\n", sep="")
    }
  }
  cat("\n")
}

cat("Results saved to:", summary_path, "\n")
cat("=============================================================\n")
```

