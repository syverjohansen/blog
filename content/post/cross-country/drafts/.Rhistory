if(race_prob_col %in% names(startlist)) {
# Copy from original startlist if available
log_info("Copying from original startlist")
startlist_prepared[[race_prob_col]] <- startlist[match(startlist_prepared$Skier, startlist$Skier), race_prob_col]
} else {
# Default to 1 for first race, 0 for others if not available
log_info("Setting default probabilities")
startlist_prepared[[race_prob_col]] <- if(i == 1) 1 else 0
}
}
# Make position probability predictions with adjustments
position_preds <- data.frame(
Skier = startlist_prepared$Skier,
ID = startlist_prepared$ID,
Nation = startlist_prepared$Nation,
Sex = startlist_prepared$Sex,
Race = i
)
# Add race probability column for later normalization
if(race_prob_col %in% names(startlist_prepared)) {
position_preds[[race_prob_col]] <- startlist_prepared[[race_prob_col]]
}
# Make predictions for each threshold
for(threshold in position_thresholds) {
model_name <- paste0("threshold_", threshold)
adj_name <- paste0("threshold_", threshold)
prob_col <- paste0("prob_top", threshold)
if(model_name %in% names(position_models)) {
tryCatch({
# Get the model
pos_model <- position_models[[model_name]]
# Check what variables the model actually needs
model_vars <- names(pos_model$var.summary)
log_info(paste("Model for threshold", threshold, "requires variables:", paste(model_vars, collapse=", ")))
# Create a clean subset of prediction data with only required variables
prediction_subset <- startlist_prepared
#print(startlist_prepared)
# Explicitly check for each variable
for(var in model_vars) {
if(!(var %in% names(prediction_subset))) {
log_warn(paste("Missing required variable:", var, "- adding with default values"))
# Add missing variable with appropriate default value
prediction_subset[[var]] <- 0
} else {
# Ensure the variable has the right type
model_var_type <- class(pos_model$var.summary[[var]])
data_var_type <- class(prediction_subset[[var]])
if(!identical(model_var_type, data_var_type)) {
log_warn(paste("Variable type mismatch for", var, ":",
"model expects", model_var_type, "but got", data_var_type))
# Convert to correct type
if(model_var_type == "numeric") {
prediction_subset[[var]] <- as.numeric(prediction_subset[[var]])
} else if(model_var_type == "factor") {
prediction_subset[[var]] <- as.factor(prediction_subset[[var]])
}
}
# Handle NAs
if(any(is.na(prediction_subset[[var]]))) {
log_info(paste("Replacing NAs in", var))
if(is.numeric(prediction_subset[[var]])) {
prediction_subset[[var]] <- replace_na_with_quartile(prediction_subset[[var]])
} else {
# For non-numeric, use most common value
most_common <- names(sort(table(prediction_subset[[var]], useNA = "no"), decreasing = TRUE))[1]
prediction_subset[[var]][is.na(prediction_subset[[var]])] <- most_common
}
}
}
}
# Make predictions with explicit try-catch
base_predictions <- tryCatch({
# Debug output
log_info(paste("Attempting prediction for threshold", threshold, "with", nrow(prediction_subset), "rows"))
# Explicit call to mgcv::predict.gam to avoid method dispatch issues
mgcv::predict.gam(pos_model, newdata = prediction_subset, type = "response")
}, error = function(e) {
log_warn(paste("Prediction call failed:", e$message))
# Try alternative prediction approach with one row at a time
log_info("Trying row-by-row prediction as fallback")
result <- numeric(nrow(prediction_subset))
for(i in 1:nrow(prediction_subset)) {
single_row <- prediction_subset[i,, drop = FALSE]
result[i] <- tryCatch({
mgcv::predict.gam(pos_model, newdata = single_row, type = "response")
}, error = function(e2) {
log_warn(paste("Failed on row", i, ":", e2$message))
threshold/100  # Default value based on threshold
})
}
return(result)
})
# Store predictions
position_preds[[paste0(prob_col, "_base")]] <- base_predictions
# Place this code right after you store base_predictions but before applying adjustments
# Create a dataframe to store base predictions
base_pred_df <- data.frame(
Skier = position_preds$Skier,
Nation = position_preds$Nation,
ID = position_preds$ID,
BaseProbability = base_predictions * 100  # Convert to percentage
)
# If we have adjustments available for this threshold
if(adj_name %in% names(position_adjustments)) {
# Get the adjustments
pos_adj <- position_adjustments[[adj_name]]
# Join adjustments with base predictions
adjustment_df <- base_pred_df %>%
left_join(pos_adj, by = "Skier") %>%
mutate(
Altitude = replace_na(altitude_effect, 0) * 100,
Period = replace_na(period_effect, 0) * 100,
MassStart = replace_na(ms_effect, 0) * 100,
TotalAdjustment = Altitude + Period + MassStart,
FinalProbability = pmin(pmax(BaseProbability + TotalAdjustment, 0), 100)
) %>%
arrange(desc(BaseProbability))
# Print header and data
cat(paste("\n\n=== Top", threshold, "Position Probabilities and Adjustments ===\n"))
#View(adjustment_df)
}
# Apply adjustments if available
if(adj_name %in% names(position_adjustments)) {
# Get adjustments
pos_adj <- position_adjustments[[adj_name]]
# Join with predictions
position_preds <- position_preds %>%
left_join(pos_adj, by = "Skier") %>%
mutate(
# Replace NAs with zeros
altitude_effect = replace_na(altitude_effect, 0),
period_effect = replace_na(period_effect, 0),
ms_effect = replace_na(ms_effect, 0),
# Apply adjustments
altitude_adjustment = altitude_effect,
period_adjustment = period_effect,
ms_adjustment = ms_effect,
# Calculate adjusted probabilities
adjusted_prob = get(paste0(prob_col, "_base")) +
altitude_adjustment + period_adjustment + ms_adjustment,
# Ensure probabilities are between 0 and 1
adjusted_prob = pmin(pmax(adjusted_prob, 0), 1)
)
# Use adjusted probability as final
position_preds[[prob_col]] <- position_preds$adjusted_prob
# Clean up temporary columns
position_preds <- position_preds %>%
dplyr::select(-altitude_effect, -period_effect, -ms_effect,
-altitude_adjustment, -period_adjustment, -ms_adjustment, -adjusted_prob)
} else {
# Use base prediction if no adjustments
position_preds[[prob_col]] <- position_preds[[paste0(prob_col, "_base")]]
}
# Clean up base prediction column
position_preds <- position_preds %>%
dplyr::select(-paste0(prob_col, "_base"))
# Convert to percentage and round
position_preds[[prob_col]] <- round(position_preds[[prob_col]] * 100, 1)
log_info(paste("Made predictions with adjustments for position threshold", threshold))
}, error = function(e) {
log_warn(paste("Complete failure for threshold", threshold, ":", e$message))
# Set a reasonable default based on threshold (1% for top1, 3% for top3, etc.)
position_preds[[prob_col]] <- rep(threshold, nrow(position_preds))
})
} else {
log_warn(paste("No model found for threshold", threshold))
position_preds[[prob_col]] <- NA
}
}
# Normalize position probabilities to ensure they sum to the correct totals
position_preds <- normalize_position_probabilities(position_preds, race_prob_col, position_thresholds)
# Add verification logging for each threshold
log_info(sprintf("Race %d position probability sums after normalization:", i))
for(threshold in position_thresholds) {
prob_col <- paste0("prob_top", threshold)
if(prob_col %in% names(position_preds)) {
sum_val <- sum(position_preds[[prob_col]], na.rm = TRUE)
log_info(sprintf("  %s: %.2f%% (should be %d%%)",
prob_col, sum_val, 100 * threshold))
# Extra verification - print top 3 skiers and their probabilities for this threshold
top_skiers <- position_preds %>%
arrange(desc(!!sym(prob_col))) %>%
head(3) %>%
dplyr::select(Skier, Nation, !!sym(prob_col))
log_info("  Top 3 skiers for this threshold:")
#print(top_skiers)
}
}
# Remove race probability column from position_preds (it's already accounted for now)
# if(race_prob_col %in% names(position_preds)) {
#  position_preds <- position_preds %>% dplyr::select(-all_of(race_prob_col))
# }
#View(position_preds)
# Store position predictions for this race
position_predictions[[i]] <- position_preds
# Check if probabilities are getting lost
log_info(paste("Race", i, "probability check:"))
prob_summary <- startlist_prepared %>%
group_by(Nation) %>%
summarise(
mean_prob = mean(get(race_prob_col), na.rm = TRUE),
sum_prob = sum(get(race_prob_col), na.rm = TRUE),
n = n()
) %>%
arrange(desc(sum_prob))
#print(prob_summary %>% head(5))
# Prepare startlist points predictions (original functionality)
race_dfs[[i]] <- startlist_prepared %>%
mutate(
Base_Prediction = predict(model, newdata = .),
) %>%
left_join(skier_adjustments, by = "Skier") %>%
mutate(
# Regular adjustments
altitude_effect = replace_na(altitude_effect, 0),
period_effect = replace_na(period_effect, 0),
ms_effect = replace_na(ms_effect, 0),
# Volatility metrics
prediction_volatility = replace_na(prediction_volatility, 0),
consistency_score = replace_na(consistency_score, 0),
upside_potential = replace_na(upside_potential, 0),
downside_risk = replace_na(downside_risk, 0),
volatility_ratio = replace_na(volatility_ratio, 1),
n_recent_races = replace_na(n_recent_races, 0),
# Using your existing adjustment approach
altitude_adjustment = altitude_effect,
period_adjustment = period_effect,
ms_adjustment = ms_effect,
# Base prediction and adjustments
Predicted_Points = Base_Prediction + altitude_adjustment +
period_adjustment + ms_adjustment,
Predicted_Points = pmax(pmin(Predicted_Points, 100), 0),
# Apply race probability to predictions
Race_Prob = get(race_prob_col),
Final_Prediction = Predicted_Points,
# Different scoring scenarios - adjusted by race probability
confidence_factor = pmin(n_recent_races / 10, 1),
scaled_upside_potential = upside_potential * (Predicted_Points/100),
scaled_downside_potential = downside_risk * (Predicted_Points/100),
# Safe prediction (downside)
Safe_Prediction = pmax(
(Predicted_Points - (prediction_volatility * 1.5 * confidence_factor)) * Race_Prob,
0
),
Safe_Prediction = pmax(
(Predicted_Points - (abs(scaled_downside_potential) * volatility_ratio * confidence_factor)) * Race_Prob,
0
),
# Upside prediction
Upside_Prediction = pmin(
(Predicted_Points + (prediction_volatility * 1.5 * confidence_factor)) * Race_Prob,
100 * Race_Prob  # Cap at 100 * probability
),
Upside_Prediction = pmin(
(Predicted_Points + (scaled_upside_potential * volatility_ratio * confidence_factor)) * Race_Prob,
100 * Race_Prob  # Cap at 100 * probability
)
) %>%
dplyr::select(Skier, Nation,
Base_Prediction, altitude_adjustment,
period_adjustment, ms_adjustment,
prediction_volatility, volatility_ratio, confidence_factor,
Predicted_Points,
Final_Prediction, Safe_Prediction, Upside_Prediction,
race_prob_col)
#View(race_dfs[[i]])
# Apply pursuit handling if needed
if(races$Pursuit[i] == 1) {
# Get startlist points
startlist_points <- startlist %>%
mutate(
# Use the appropriate points system based on the Stage flag
startlist_points = case_when(
row_number() <= length(if(is_stage_race) stage_points else wc_points) ~
(if(is_stage_race) stage_points else wc_points)[row_number()],
TRUE ~ 0
)
) %>%
dplyr::select(Skier, startlist_points)
# Apply pursuit logic - average predicted points with startlist points
# Also account for race probability
race_dfs[[i]] <- race_dfs[[i]] %>%
left_join(startlist_points, by = "Skier") %>%
mutate(
startlist_points = replace_na(startlist_points, 0),
Race_Prob = get(race_prob_col),
# Weighted average of predicted points and startlist points, then apply race probability
Final_Prediction = ((Predicted_Points + startlist_points) / 2) * Race_Prob,
Safe_Prediction = ((Safe_Prediction/Race_Prob + startlist_points) / 2) * Race_Prob,
Upside_Prediction = ((Upside_Prediction/Race_Prob + startlist_points) / 2) * Race_Prob
) %>%
dplyr::select(-startlist_points)
log_info(paste("Applied pursuit logic to race", i))
}
# Extra check to ensure race probability column exists and is properly named
if(!race_prob_col %in% names(race_dfs[[i]])) {
log_warn(paste("Race probability column", race_prob_col, "not in final race_dfs!"))
# Try to fix
if("Race_Prob" %in% names(race_dfs[[i]])) {
log_info("Renaming Race_Prob column to correct race probability column name")
race_dfs[[i]][[race_prob_col]] <- race_dfs[[i]][["Race_Prob"]]
}
}
}
# Get number of races from races dataframe
n_races <- nrow(races)
# Combine all race predictions (points)
final_predictions <- combine_predictions(race_dfs, startlist)
log_info(paste("Final predictions calculated for", gender))
# Create post predictions for blog (points)
post_predictions <- create_post_predictions(final_predictions, n_races, gender)
# NEW: Combine all position predictions into one dataframe
all_position_predictions <- bind_rows(position_predictions)
# NEW: Create formatted position probabilities
formatted_position_results <- format_position_results(all_position_predictions, next_weekend_date, gender)
# Create folder path based on next race weekend date
weekend_folder <- format(next_weekend_date, "%Y%m%d")
dir_path <- paste0("~/blog/daehl-e/content/post/cross-country/drafts/weekly-picks/", weekend_folder)
# Create directory if it doesn't exist
if (!dir.exists(dir_path)) {
dir.create(dir_path, recursive = TRUE)
}
# Save points predictions to Excel
points_file_path <- file.path(dir_path, paste0(ifelse(gender == "men", "men", "ladies"), ".xlsx"))
write.xlsx(post_predictions, file = points_file_path)
log_info(paste("Saved", gender, "points predictions to", points_file_path))
# Return both points and position predictions
return(list(
full_predictions = final_predictions,
post_predictions = post_predictions,
position_predictions = all_position_predictions,
formatted_position_results = formatted_position_results
))
}
# Helper function to format position probability results
# Helper function to format position probability results
format_position_results <- function(position_results, next_weekend_date, gender) {
# Create a more reader-friendly version
#View(position_results)
formatted_results <- position_results %>%
rowwise() %>%
mutate(
# Get the appropriate race probability column for the current row's Race number
race_prob_col = paste0("Race", Race, "_Prob"),
Participation = if(race_prob_col %in% names(position_results)) position_results[[race_prob_col]][cur_group_id()] else NA_real_,
Win = prob_top1,
Podium = prob_top3,
Top5 = prob_top5,
Top10 = prob_top10,
Top30 = prob_top30
) %>%
ungroup() %>%
dplyr::select(Skier, ID, Nation, Sex, Race, Participation, Win, Podium, Top5, Top10, Top30) %>%
arrange(Race, desc(Win))
weekend_folder <- format(next_weekend_date, "%Y%m%d")
dir_path <- paste0(
"~/blog/daehl-e/content/post/cross-country/drafts/weekly-picks/",
weekend_folder
)
if (!dir.exists(dir_path)) {
dir.create(dir_path, recursive = TRUE)
}
# Split by race
races <- unique(formatted_results$Race)
race_dfs <- list()
for(race_num in races) {
race_df <- formatted_results %>%
filter(Race == race_num) %>%
dplyr::select(-Race)
sheet_name <- paste0(
ifelse(gender == "men", "Men", "Ladies"),
" Race ", race_num
)
race_dfs[[sheet_name]] <- race_df
}
# Save to Excel
output_file <- file.path(
dir_path,
paste0(ifelse(gender == "men", "men", "ladies"), "_position_probabilities.xlsx")
)
write.xlsx(race_dfs, output_file)
log_info(paste("Formatted position probabilities saved to", output_file))
return(race_dfs)
}
# Function to create top contenders summary
create_top_contenders_summary <- function(men_results, ladies_results) {
# Get position predictions
men_positions <- men_results$position_predictions
ladies_positions <- ladies_results$position_predictions
weekend_folder <- format(next_weekend_date, "%Y%m%d")
dir_path <- paste0(
"~/blog/daehl-e/content/post/cross-country/drafts/weekly-picks/",
weekend_folder
)
if (!dir.exists(dir_path)) {
dir.create(dir_path, recursive = TRUE)
}
top_contenders <- list()
# Process men's results
men_races <- unique(men_positions$Race)
for(race_num in men_races) {
race_df <- men_positions %>%
filter(Race == race_num)
# Top 5 for win probability
win_contenders <- race_df %>%
arrange(desc(prob_top1)) %>%
head(5) %>%
dplyr::select(Skier, Nation, prob_top1) %>%
rename(`Win%` = prob_top1)
sheet_name <- paste0("Men Race ", race_num, " - Win")
top_contenders[[sheet_name]] <- win_contenders
# Top 5 for podium probability
podium_contenders <- race_df %>%
arrange(desc(prob_top3)) %>%
head(5) %>%
dplyr::select(Skier, Nation, prob_top3) %>%
rename(`Podium%` = prob_top3)
sheet_name <- paste0("Men Race ", race_num, " - Podium")
top_contenders[[sheet_name]] <- podium_contenders
# Top 5 for Top-5 probability
top5_contenders <- race_df %>%
arrange(desc(prob_top5)) %>%
head(5) %>%
dplyr::select(Skier, Nation, prob_top5) %>%
rename(`Top5%` = prob_top5)
sheet_name <- paste0("Men Race ", race_num, " - Top5")
top_contenders[[sheet_name]] <- top5_contenders
}
# Process ladies' results
ladies_races <- unique(ladies_positions$Race)
for(race_num in ladies_races) {
race_df <- ladies_positions %>%
filter(Race == race_num)
# Top 5 for win probability
win_contenders <- race_df %>%
arrange(desc(prob_top1)) %>%
head(5) %>%
dplyr::select(Skier, Nation, prob_top1) %>%
rename(`Win%` = prob_top1)
sheet_name <- paste0("Ladies Race ", race_num, " - Win")
top_contenders[[sheet_name]] <- win_contenders
# Top 5 for podium probability
podium_contenders <- race_df %>%
arrange(desc(prob_top3)) %>%
head(5) %>%
dplyr::select(Skier, Nation, prob_top3) %>%
rename(`Podium%` = prob_top3)
sheet_name <- paste0("Ladies Race ", race_num, " - Podium")
top_contenders[[sheet_name]] <- podium_contenders
# Top 5 for Top-5 probability
top5_contenders <- race_df %>%
arrange(desc(prob_top5)) %>%
head(5) %>%
dplyr::select(Skier, Nation, prob_top5) %>%
rename(`Top5%` = prob_top5)
sheet_name <- paste0("Ladies Race ", race_num, " - Top5")
top_contenders[[sheet_name]] <- top5_contenders
}
# Save to Excel
output_file <- file.path(dir_path, "top_contenders.xlsx")
#write.xlsx(top_contenders, output_file)
log_info(paste("Top contenders summary saved to", output_file))
return(top_contenders)
}
# Run the integrated predictions workflow
run_integrated_predictions_workflow <- function() {
log_info("Running integrated predictions workflow (points and position probabilities)")
# Run for men
log_info("Processing men's predictions")
men_results <- predict_races("men")
# Run for ladies
log_info("Processing ladies predictions")
ladies_results <- predict_races("ladies")
# Create top contenders summary
top_contenders <- create_top_contenders_summary(men_results, ladies_results)
# Run fantasy optimization
fantasy_results <- run_fantasy_optimization(men_results, ladies_results, next_weekend_date)
# Display sample results
log_info("Prediction workflow complete")
# Return results
return(list(
men = men_results,
ladies = ladies_results,
top_contenders = top_contenders,
fantasy = fantasy_results
))
}
# First calculate race probabilities
log_info("Calculating race probabilities")
prob_results <- calculate_race_probabilities()
log_info("Updating startlist variables with calculated probabilities")
men_startlist <- prob_results$men
ladies_startlist <- prob_results$ladies
# Run integrated predictions workflow
log_info("Running integrated predictions workflow")
integrated_results <- run_integrated_predictions_workflow()
# Display race probability impact on fantasy picks
cat("\nRace Probability Impact on Top Fantasy Picks:\n")
top_fantasy_skiers <- c(
integrated_results$fantasy$normal_team$Skier[1:5],
integrated_results$fantasy$safe_team$Skier[1:2],
integrated_results$fantasy$upside_team$Skier[1:2]
)
top_skiers_probs <- integrated_results$men$full_predictions %>%
filter(Skier %in% top_fantasy_skiers) %>%
dplyr::select(Skier, Nation, contains("Race1_Prob"), contains("Race2_Prob"), Total_Points) %>%
arrange(desc(Total_Points))
# Show comparison of optimized teams
cat("\nComparison of Different Optimization Strategies:\n")
cat("Normal Team Total Points:", sum(integrated_results$fantasy$normal_team$Points), "\n")
cat("Safe Team Total Points:", sum(integrated_results$fantasy$safe_team$Points), "\n")
cat("Upside Team Total Points:", sum(integrated_results$fantasy$upside_team$Points), "\n")
